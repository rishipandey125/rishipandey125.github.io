import {
  LevaPanel,
  button,
  useControls,
  useCreateStore
} from "./chunk-I7DYWVNN.js";
import "./chunk-G6ZLLUTD.js";
import "./chunk-XYPPRK5G.js";
import "./chunk-JTANXVDO.js";
import {
  require_client
} from "./chunk-HPJWAITJ.js";
import "./chunk-OHGGG33N.js";
import {
  extend
} from "./chunk-OYEWVWWR.js";
import {
  Color,
  Material,
  MathUtils,
  Matrix3,
  Matrix4,
  MeshBasicMaterial,
  MeshLambertMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  Texture,
  TextureLoader,
  Vector2,
  Vector3,
  Vector4
} from "./chunk-GHEAFNOU.js";
import {
  _extends
} from "./chunk-7CYDX2RJ.js";
import {
  require_react
} from "./chunk-7XDTT3EY.js";
import {
  __commonJS,
  __require,
  __toESM
} from "./chunk-BHN6OJC3.js";

// node_modules/glsl-tokenizer/lib/literals.js
var require_literals = __commonJS({
  "node_modules/glsl-tokenizer/lib/literals.js"(exports, module) {
    module.exports = [
      "precision",
      "highp",
      "mediump",
      "lowp",
      "attribute",
      "const",
      "uniform",
      "varying",
      "break",
      "continue",
      "do",
      "for",
      "while",
      "if",
      "else",
      "in",
      "out",
      "inout",
      "float",
      "int",
      "uint",
      "void",
      "bool",
      "true",
      "false",
      "discard",
      "return",
      "mat2",
      "mat3",
      "mat4",
      "vec2",
      "vec3",
      "vec4",
      "ivec2",
      "ivec3",
      "ivec4",
      "bvec2",
      "bvec3",
      "bvec4",
      "sampler1D",
      "sampler2D",
      "sampler3D",
      "samplerCube",
      "sampler1DShadow",
      "sampler2DShadow",
      "struct",
      "asm",
      "class",
      "union",
      "enum",
      "typedef",
      "template",
      "this",
      "packed",
      "goto",
      "switch",
      "default",
      "inline",
      "noinline",
      "volatile",
      "public",
      "static",
      "extern",
      "external",
      "interface",
      "long",
      "short",
      "double",
      "half",
      "fixed",
      "unsigned",
      "input",
      "output",
      "hvec2",
      "hvec3",
      "hvec4",
      "dvec2",
      "dvec3",
      "dvec4",
      "fvec2",
      "fvec3",
      "fvec4",
      "sampler2DRect",
      "sampler3DRect",
      "sampler2DRectShadow",
      "sizeof",
      "cast",
      "namespace",
      "using"
    ];
  }
});

// node_modules/glsl-tokenizer/lib/operators.js
var require_operators = __commonJS({
  "node_modules/glsl-tokenizer/lib/operators.js"(exports, module) {
    module.exports = [
      "<<=",
      ">>=",
      "++",
      "--",
      "<<",
      ">>",
      "<=",
      ">=",
      "==",
      "!=",
      "&&",
      "||",
      "+=",
      "-=",
      "*=",
      "/=",
      "%=",
      "&=",
      "^^",
      "^=",
      "|=",
      "(",
      ")",
      "[",
      "]",
      ".",
      "!",
      "~",
      "*",
      "/",
      "%",
      "+",
      "-",
      "<",
      ">",
      "&",
      "^",
      "|",
      "?",
      ":",
      "=",
      ",",
      ";",
      "{",
      "}"
    ];
  }
});

// node_modules/glsl-tokenizer/lib/builtins.js
var require_builtins = __commonJS({
  "node_modules/glsl-tokenizer/lib/builtins.js"(exports, module) {
    module.exports = [
      "abs",
      "acos",
      "all",
      "any",
      "asin",
      "atan",
      "ceil",
      "clamp",
      "cos",
      "cross",
      "dFdx",
      "dFdy",
      "degrees",
      "distance",
      "dot",
      "equal",
      "exp",
      "exp2",
      "faceforward",
      "floor",
      "fract",
      "gl_BackColor",
      "gl_BackLightModelProduct",
      "gl_BackLightProduct",
      "gl_BackMaterial",
      "gl_BackSecondaryColor",
      "gl_ClipPlane",
      "gl_ClipVertex",
      "gl_Color",
      "gl_DepthRange",
      "gl_DepthRangeParameters",
      "gl_EyePlaneQ",
      "gl_EyePlaneR",
      "gl_EyePlaneS",
      "gl_EyePlaneT",
      "gl_Fog",
      "gl_FogCoord",
      "gl_FogFragCoord",
      "gl_FogParameters",
      "gl_FragColor",
      "gl_FragCoord",
      "gl_FragData",
      "gl_FragDepth",
      "gl_FragDepthEXT",
      "gl_FrontColor",
      "gl_FrontFacing",
      "gl_FrontLightModelProduct",
      "gl_FrontLightProduct",
      "gl_FrontMaterial",
      "gl_FrontSecondaryColor",
      "gl_LightModel",
      "gl_LightModelParameters",
      "gl_LightModelProducts",
      "gl_LightProducts",
      "gl_LightSource",
      "gl_LightSourceParameters",
      "gl_MaterialParameters",
      "gl_MaxClipPlanes",
      "gl_MaxCombinedTextureImageUnits",
      "gl_MaxDrawBuffers",
      "gl_MaxFragmentUniformComponents",
      "gl_MaxLights",
      "gl_MaxTextureCoords",
      "gl_MaxTextureImageUnits",
      "gl_MaxTextureUnits",
      "gl_MaxVaryingFloats",
      "gl_MaxVertexAttribs",
      "gl_MaxVertexTextureImageUnits",
      "gl_MaxVertexUniformComponents",
      "gl_ModelViewMatrix",
      "gl_ModelViewMatrixInverse",
      "gl_ModelViewMatrixInverseTranspose",
      "gl_ModelViewMatrixTranspose",
      "gl_ModelViewProjectionMatrix",
      "gl_ModelViewProjectionMatrixInverse",
      "gl_ModelViewProjectionMatrixInverseTranspose",
      "gl_ModelViewProjectionMatrixTranspose",
      "gl_MultiTexCoord0",
      "gl_MultiTexCoord1",
      "gl_MultiTexCoord2",
      "gl_MultiTexCoord3",
      "gl_MultiTexCoord4",
      "gl_MultiTexCoord5",
      "gl_MultiTexCoord6",
      "gl_MultiTexCoord7",
      "gl_Normal",
      "gl_NormalMatrix",
      "gl_NormalScale",
      "gl_ObjectPlaneQ",
      "gl_ObjectPlaneR",
      "gl_ObjectPlaneS",
      "gl_ObjectPlaneT",
      "gl_Point",
      "gl_PointCoord",
      "gl_PointParameters",
      "gl_PointSize",
      "gl_Position",
      "gl_ProjectionMatrix",
      "gl_ProjectionMatrixInverse",
      "gl_ProjectionMatrixInverseTranspose",
      "gl_ProjectionMatrixTranspose",
      "gl_SecondaryColor",
      "gl_TexCoord",
      "gl_TextureEnvColor",
      "gl_TextureMatrix",
      "gl_TextureMatrixInverse",
      "gl_TextureMatrixInverseTranspose",
      "gl_TextureMatrixTranspose",
      "gl_Vertex",
      "greaterThan",
      "greaterThanEqual",
      "inversesqrt",
      "length",
      "lessThan",
      "lessThanEqual",
      "log",
      "log2",
      "matrixCompMult",
      "max",
      "min",
      "mix",
      "mod",
      "normalize",
      "not",
      "notEqual",
      "pow",
      "radians",
      "reflect",
      "refract",
      "sign",
      "sin",
      "smoothstep",
      "sqrt",
      "step",
      "tan",
      "texture2D",
      "texture2DLod",
      "texture2DProj",
      "texture2DProjLod",
      "textureCube",
      "textureCubeLod",
      "texture2DLodEXT",
      "texture2DProjLodEXT",
      "textureCubeLodEXT",
      "texture2DGradEXT",
      "texture2DProjGradEXT",
      "textureCubeGradEXT"
    ];
  }
});

// node_modules/glsl-tokenizer/lib/literals-300es.js
var require_literals_300es = __commonJS({
  "node_modules/glsl-tokenizer/lib/literals-300es.js"(exports, module) {
    var v100 = require_literals();
    module.exports = v100.slice().concat([
      "layout",
      "centroid",
      "smooth",
      "case",
      "mat2x2",
      "mat2x3",
      "mat2x4",
      "mat3x2",
      "mat3x3",
      "mat3x4",
      "mat4x2",
      "mat4x3",
      "mat4x4",
      "uvec2",
      "uvec3",
      "uvec4",
      "samplerCubeShadow",
      "sampler2DArray",
      "sampler2DArrayShadow",
      "isampler2D",
      "isampler3D",
      "isamplerCube",
      "isampler2DArray",
      "usampler2D",
      "usampler3D",
      "usamplerCube",
      "usampler2DArray",
      "coherent",
      "restrict",
      "readonly",
      "writeonly",
      "resource",
      "atomic_uint",
      "noperspective",
      "patch",
      "sample",
      "subroutine",
      "common",
      "partition",
      "active",
      "filter",
      "image1D",
      "image2D",
      "image3D",
      "imageCube",
      "iimage1D",
      "iimage2D",
      "iimage3D",
      "iimageCube",
      "uimage1D",
      "uimage2D",
      "uimage3D",
      "uimageCube",
      "image1DArray",
      "image2DArray",
      "iimage1DArray",
      "iimage2DArray",
      "uimage1DArray",
      "uimage2DArray",
      "image1DShadow",
      "image2DShadow",
      "image1DArrayShadow",
      "image2DArrayShadow",
      "imageBuffer",
      "iimageBuffer",
      "uimageBuffer",
      "sampler1DArray",
      "sampler1DArrayShadow",
      "isampler1D",
      "isampler1DArray",
      "usampler1D",
      "usampler1DArray",
      "isampler2DRect",
      "usampler2DRect",
      "samplerBuffer",
      "isamplerBuffer",
      "usamplerBuffer",
      "sampler2DMS",
      "isampler2DMS",
      "usampler2DMS",
      "sampler2DMSArray",
      "isampler2DMSArray",
      "usampler2DMSArray"
    ]);
  }
});

// node_modules/glsl-tokenizer/lib/builtins-300es.js
var require_builtins_300es = __commonJS({
  "node_modules/glsl-tokenizer/lib/builtins-300es.js"(exports, module) {
    var v100 = require_builtins();
    v100 = v100.slice().filter(function(b) {
      return !/^(gl\_|texture)/.test(b);
    });
    module.exports = v100.concat([
      "gl_VertexID",
      "gl_InstanceID",
      "gl_Position",
      "gl_PointSize",
      "gl_FragCoord",
      "gl_FrontFacing",
      "gl_FragDepth",
      "gl_PointCoord",
      "gl_MaxVertexAttribs",
      "gl_MaxVertexUniformVectors",
      "gl_MaxVertexOutputVectors",
      "gl_MaxFragmentInputVectors",
      "gl_MaxVertexTextureImageUnits",
      "gl_MaxCombinedTextureImageUnits",
      "gl_MaxTextureImageUnits",
      "gl_MaxFragmentUniformVectors",
      "gl_MaxDrawBuffers",
      "gl_MinProgramTexelOffset",
      "gl_MaxProgramTexelOffset",
      "gl_DepthRangeParameters",
      "gl_DepthRange",
      "trunc",
      "round",
      "roundEven",
      "isnan",
      "isinf",
      "floatBitsToInt",
      "floatBitsToUint",
      "intBitsToFloat",
      "uintBitsToFloat",
      "packSnorm2x16",
      "unpackSnorm2x16",
      "packUnorm2x16",
      "unpackUnorm2x16",
      "packHalf2x16",
      "unpackHalf2x16",
      "outerProduct",
      "transpose",
      "determinant",
      "inverse",
      "texture",
      "textureSize",
      "textureProj",
      "textureLod",
      "textureOffset",
      "texelFetch",
      "texelFetchOffset",
      "textureProjOffset",
      "textureLodOffset",
      "textureProjLod",
      "textureProjLodOffset",
      "textureGrad",
      "textureGradOffset",
      "textureProjGrad",
      "textureProjGradOffset"
    ]);
  }
});

// node_modules/glsl-tokenizer/index.js
var require_glsl_tokenizer = __commonJS({
  "node_modules/glsl-tokenizer/index.js"(exports, module) {
    module.exports = tokenize3;
    var literals100 = require_literals();
    var operators = require_operators();
    var builtins100 = require_builtins();
    var literals300es = require_literals_300es();
    var builtins300es = require_builtins_300es();
    var NORMAL = 999;
    var TOKEN = 9999;
    var BLOCK_COMMENT = 0;
    var LINE_COMMENT = 1;
    var PREPROCESSOR = 2;
    var OPERATOR = 3;
    var INTEGER = 4;
    var FLOAT = 5;
    var IDENT = 6;
    var BUILTIN = 7;
    var KEYWORD = 8;
    var WHITESPACE = 9;
    var EOF = 10;
    var HEX = 11;
    var map = [
      "block-comment",
      "line-comment",
      "preprocessor",
      "operator",
      "integer",
      "float",
      "ident",
      "builtin",
      "keyword",
      "whitespace",
      "eof",
      "integer"
    ];
    function tokenize3(opt) {
      var i = 0, total = 0, mode = NORMAL, c, last, content = [], tokens = [], token_idx = 0, token_offs = 0, line = 1, col = 0, start = 0, isnum = false, isoperator = false, input = "", len;
      opt = opt || {};
      var allBuiltins = builtins100;
      var allLiterals = literals100;
      if (opt.version === "300 es") {
        allBuiltins = builtins300es;
        allLiterals = literals300es;
      }
      var builtinsDict = {}, literalsDict = {};
      for (var i = 0; i < allBuiltins.length; i++) {
        builtinsDict[allBuiltins[i]] = true;
      }
      for (var i = 0; i < allLiterals.length; i++) {
        literalsDict[allLiterals[i]] = true;
      }
      return function(data) {
        tokens = [];
        if (data !== null)
          return write(data);
        return end();
      };
      function token(data) {
        if (data.length) {
          tokens.push({
            type: map[mode],
            data,
            position: start,
            line,
            column: col
          });
        }
      }
      function write(chunk) {
        i = 0;
        if (chunk.toString)
          chunk = chunk.toString();
        input += chunk.replace(/\r\n/g, "\n");
        len = input.length;
        var last2;
        while (c = input[i], i < len) {
          last2 = i;
          switch (mode) {
            case BLOCK_COMMENT:
              i = block_comment();
              break;
            case LINE_COMMENT:
              i = line_comment();
              break;
            case PREPROCESSOR:
              i = preprocessor();
              break;
            case OPERATOR:
              i = operator();
              break;
            case INTEGER:
              i = integer();
              break;
            case HEX:
              i = hex();
              break;
            case FLOAT:
              i = decimal();
              break;
            case TOKEN:
              i = readtoken();
              break;
            case WHITESPACE:
              i = whitespace();
              break;
            case NORMAL:
              i = normal();
              break;
          }
          if (last2 !== i) {
            switch (input[last2]) {
              case "\n":
                col = 0;
                ++line;
                break;
              default:
                ++col;
                break;
            }
          }
        }
        total += i;
        input = input.slice(i);
        return tokens;
      }
      function end(chunk) {
        if (content.length) {
          token(content.join(""));
        }
        mode = EOF;
        token("(eof)");
        return tokens;
      }
      function normal() {
        content = content.length ? [] : content;
        if (last === "/" && c === "*") {
          start = total + i - 1;
          mode = BLOCK_COMMENT;
          last = c;
          return i + 1;
        }
        if (last === "/" && c === "/") {
          start = total + i - 1;
          mode = LINE_COMMENT;
          last = c;
          return i + 1;
        }
        if (c === "#") {
          mode = PREPROCESSOR;
          start = total + i;
          return i;
        }
        if (/\s/.test(c)) {
          mode = WHITESPACE;
          start = total + i;
          return i;
        }
        isnum = /\d/.test(c);
        isoperator = /[^\w_]/.test(c);
        start = total + i;
        mode = isnum ? INTEGER : isoperator ? OPERATOR : TOKEN;
        return i;
      }
      function whitespace() {
        if (/[^\s]/g.test(c)) {
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function preprocessor() {
        if ((c === "\r" || c === "\n") && last !== "\\") {
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function line_comment() {
        return preprocessor();
      }
      function block_comment() {
        if (c === "/" && last === "*") {
          content.push(c);
          token(content.join(""));
          mode = NORMAL;
          return i + 1;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function operator() {
        if (last === "." && /\d/.test(c)) {
          mode = FLOAT;
          return i;
        }
        if (last === "/" && c === "*") {
          mode = BLOCK_COMMENT;
          return i;
        }
        if (last === "/" && c === "/") {
          mode = LINE_COMMENT;
          return i;
        }
        if (c === "." && content.length) {
          while (determine_operator(content))
            ;
          mode = FLOAT;
          return i;
        }
        if (c === ";" || c === ")" || c === "(") {
          if (content.length)
            while (determine_operator(content))
              ;
          token(c);
          mode = NORMAL;
          return i + 1;
        }
        var is_composite_operator = content.length === 2 && c !== "=";
        if (/[\w_\d\s]/.test(c) || is_composite_operator) {
          while (determine_operator(content))
            ;
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function determine_operator(buf) {
        var j = 0, idx, res;
        do {
          idx = operators.indexOf(buf.slice(0, buf.length + j).join(""));
          res = operators[idx];
          if (idx === -1) {
            if (j-- + buf.length > 0)
              continue;
            res = buf.slice(0, 1).join("");
          }
          token(res);
          start += res.length;
          content = content.slice(res.length);
          return content.length;
        } while (1);
      }
      function hex() {
        if (/[^a-fA-F0-9]/.test(c)) {
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function integer() {
        if (c === ".") {
          content.push(c);
          mode = FLOAT;
          last = c;
          return i + 1;
        }
        if (/[eE]/.test(c)) {
          content.push(c);
          mode = FLOAT;
          last = c;
          return i + 1;
        }
        if (c === "x" && content.length === 1 && content[0] === "0") {
          mode = HEX;
          content.push(c);
          last = c;
          return i + 1;
        }
        if (/[^\d]/.test(c)) {
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function decimal() {
        if (c === "f") {
          content.push(c);
          last = c;
          i += 1;
        }
        if (/[eE]/.test(c)) {
          content.push(c);
          last = c;
          return i + 1;
        }
        if ((c === "-" || c === "+") && /[eE]/.test(last)) {
          content.push(c);
          last = c;
          return i + 1;
        }
        if (/[^\d]/.test(c)) {
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
      function readtoken() {
        if (/[^\d\w_]/.test(c)) {
          var contentstr = content.join("");
          if (literalsDict[contentstr]) {
            mode = KEYWORD;
          } else if (builtinsDict[contentstr]) {
            mode = BUILTIN;
          } else {
            mode = IDENT;
          }
          token(content.join(""));
          mode = NORMAL;
          return i;
        }
        content.push(c);
        last = c;
        return i + 1;
      }
    }
  }
});

// node_modules/glsl-tokenizer/string.js
var require_string = __commonJS({
  "node_modules/glsl-tokenizer/string.js"(exports, module) {
    var tokenize3 = require_glsl_tokenizer();
    module.exports = tokenizeString;
    function tokenizeString(str, opt) {
      var generator = tokenize3(opt);
      var tokens = [];
      tokens = tokens.concat(generator(str));
      tokens = tokens.concat(generator(null));
      return tokens;
    }
  }
});

// node_modules/glsl-token-depth/index.js
var require_glsl_token_depth = __commonJS({
  "node_modules/glsl-token-depth/index.js"(exports, module) {
    module.exports = getTokenDepth;
    function getTokenDepth(tokens) {
      var loop = false;
      var depth = 0;
      for (var i = 0; i < tokens.length; i++) {
        loop = loop || tokens[i].type === "keyword" && tokens[i].data === "for";
        switch (tokens[i].data) {
          case "(":
            tokens[i].depth = loop ? depth++ : depth;
            break;
          case "{":
            tokens[i].depth = loop ? depth : depth++;
            loop = false;
            break;
          case "}":
            tokens[i].depth = --depth;
            break;
          default:
            tokens[i].depth = depth;
        }
      }
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        var index = i + 1;
        if (token.type !== "ident" && token.type !== "keyword")
          continue;
        skipArrayArguments();
        if (tokens[index].type !== "ident")
          continue;
        skipArrayArguments();
        index++;
        if (tokens[index].data !== "(")
          continue;
        while (tokens[index] && tokens[index].data !== ";" && tokens[index].data !== "{") {
          tokens[index++].depth++;
        }
        if (tokens[index] && tokens[index].data === "{")
          tokens[index].depth++;
      }
      return tokens;
      function skipArrayArguments() {
        while (tokens[index] && (tokens[index].type === "whitespace" || tokens[index].data === "[" || tokens[index].data === "]" || tokens[index].data === "integer"))
          index++;
      }
    }
  }
});

// node_modules/glsl-token-scope/index.js
var require_glsl_token_scope = __commonJS({
  "node_modules/glsl-token-scope/index.js"(exports, module) {
    module.exports = tokenScope;
    function tokenScope(tokens) {
      var stack = [0];
      var inc = stack[0];
      var ldepth = 0;
      if (!tokens || !tokens.length)
        return tokens;
      if (!("depth" in tokens[0])) {
        throw new Error("glsl-token-scope: No scope depth defined on tokens! Use glsl-token-depth on these tokens first");
      }
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        var depth = token.depth;
        if (depth > ldepth) {
          stack.push(++inc);
        } else if (depth < ldepth) {
          stack.splice(-1, 1);
        }
        token.scope = stack[stack.length - 1];
        token.stack = stack.slice();
        ldepth = token.depth;
      }
      return tokens;
    }
  }
});

// node_modules/glsl-token-properties/index.js
var require_glsl_token_properties = __commonJS({
  "node_modules/glsl-token-properties/index.js"(exports, module) {
    module.exports = properties;
    function properties(tokens) {
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        token.property = false;
        if (token.type !== "ident")
          continue;
        var j = i;
        while (tokens[--j] && tokens[j].type === "whitespace")
          ;
        if (!tokens[j])
          continue;
        if (tokens[j].type !== "operator")
          continue;
        if (tokens[j].data !== ".")
          continue;
        token.property = true;
      }
      return tokens;
    }
  }
});

// node_modules/glsl-token-assignments/assignments.js
var require_assignments = __commonJS({
  "node_modules/glsl-token-assignments/assignments.js"(exports, module) {
    module.exports = {
      "<<=": true,
      ">>=": true,
      "++": true,
      "--": true,
      "+=": true,
      "-=": true,
      "*=": true,
      "/=": true,
      "%=": true,
      "&=": true,
      "^=": true,
      "|=": true,
      "=": true
    };
  }
});

// node_modules/glsl-token-assignments/ignored.js
var require_ignored = __commonJS({
  "node_modules/glsl-token-assignments/ignored.js"(exports, module) {
    module.exports = {
      "precision": true,
      "highp": true,
      "mediump": true,
      "lowp": true,
      "attribute": true,
      "const": true,
      "uniform": true,
      "varying": true,
      "break": true,
      "continue": true,
      "do": true,
      "for": true,
      "while": true,
      "if": true,
      "else": true,
      "in": true,
      "out": true,
      "inout": true,
      "true": true,
      "false": true,
      "return": true
    };
  }
});

// node_modules/glsl-token-assignments/index.js
var require_glsl_token_assignments = __commonJS({
  "node_modules/glsl-token-assignments/index.js"(exports, module) {
    var assignments = require_assignments();
    var ignoredKeywords = require_ignored();
    module.exports = assigns;
    function assigns(tokens) {
      var idx = 0;
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        var type = token.type;
        token.assignment = false;
        token.declaration = false;
        if (type !== "ident" && type !== "builtin")
          continue;
        idx = i + 1;
        skipWhitespace(1);
        if (tokens[idx].type !== "operator")
          continue;
        if (!assignments[tokens[idx].data])
          continue;
        token.assignment = true;
      }
      for (var i = 0; i < tokens.length; i++) {
        var datatype = tokens[i];
        var type = datatype.type;
        var data = datatype.data;
        datatype.declaration = false;
        if (type === "keyword") {
          if (ignoredKeywords[data])
            continue;
        } else if (type !== "ident")
          continue;
        idx = i + 1;
        skipArrayDimensions();
        if (tokens[idx].type !== "ident")
          continue;
        tokens[idx++].declaration = true;
        skipArrayDimensions();
        if (tokens[idx].data === "(") {
          idx++;
          skipWhitespace(1);
          while (tokens[idx] && tokens[idx].data !== ")") {
            if (tokens[idx].type !== "keyword" && tokens[idx].type !== "ident")
              break;
            idx++;
            skipWhitespace(1);
            if (tokens[idx].type !== "ident")
              continue;
            tokens[idx++].declaration = true;
            skipWhitespace(1);
            skipArrayDimensions();
            skipWhitespace(1);
            if (tokens[idx].data !== ",")
              continue;
            idx++;
            skipWhitespace(1);
          }
          i = idx;
          continue;
        }
        while (tokens[idx] && tokens[idx].data !== ";") {
          if (tokens[idx].data === ",") {
            idx++;
            skipWhitespace(1);
            if (tokens[idx].declaration = tokens[idx].type === "ident")
              idx++;
          } else {
            skipWhitespace(1);
            skipParens();
            skipWhitespace(1);
            idx++;
          }
        }
        i = idx;
      }
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        if (token.type !== "keyword")
          continue;
        if (token.data !== "struct")
          continue;
        idx = i + 1;
        skipWhitespace(1);
        if (tokens[idx].type !== "ident")
          continue;
        idx++;
        skipWhitespace(1);
        if (tokens[idx++].data !== "{")
          continue;
        skipWhitespace(1);
        while (tokens[idx].type === "ident" || tokens[idx].type === "keyword") {
          do {
            idx++;
            skipWhitespace(1);
            tokens[idx].structMember = true;
            tokens[idx].declaration = false;
            idx++;
            skipArrayDimensions();
          } while (tokens[idx].data === ",");
          if (tokens[idx].data === ";")
            idx++;
          skipWhitespace();
        }
        idx++;
        skipWhitespace(1);
        if (tokens[idx].type !== "ident")
          continue;
        tokens[idx].declaration = true;
        skipWhitespace(1);
        while (tokens[++idx].data === ",") {
          skipWhitespace(1);
          idx++;
          skipWhitespace(1);
          if (tokens[idx].type === "ident")
            tokens[idx].declaration = true;
          skipWhitespace(1);
        }
      }
      return tokens;
      function skipWhitespace(n) {
        while (tokens[idx] && tokens[idx].type === "whitespace")
          idx++;
      }
      function skipArrayDimensions() {
        while (tokens[idx] && (tokens[idx].type === "integer" || tokens[idx].data === "[" || tokens[idx].data === "]" || tokens[idx].type === "whitespace"))
          idx++;
      }
      function skipParens() {
        if (!tokens[idx])
          return;
        if (tokens[idx].data !== "(")
          return;
        var depth = 0;
        var a = idx;
        do {
          if (tokens[idx].data === ";")
            break;
          if (tokens[idx].data === "(")
            depth++;
          if (tokens[idx].data === ")")
            depth--;
        } while (depth && tokens[++idx]);
      }
    }
  }
});

// node_modules/glsl-token-descope/index.js
var require_glsl_token_descope = __commonJS({
  "node_modules/glsl-token-descope/index.js"(exports, module) {
    module.exports = glslTokenDescope;
    function glslTokenDescope(tokens, rename) {
      require_glsl_token_depth()(tokens);
      require_glsl_token_scope()(tokens);
      require_glsl_token_properties()(tokens);
      require_glsl_token_assignments()(tokens);
      var scope = getScope(tokens);
      var renamer = rename || defaultRenamer();
      var map = {};
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        var stack = token.stack;
        var name = token.data;
        token.descoped = false;
        if (token.type !== "ident")
          continue;
        if (token.property)
          continue;
        if (token.structMember)
          continue;
        var bound = false;
        for (var j = stack.length - 1; j >= 0; j--) {
          var s = scope[stack[j]];
          if (!s)
            continue;
          if (!s[name])
            continue;
          bound = true;
          if (j)
            break;
          token.descoped = token.data;
          token.data = map[name] = map[name] || renamer(name, token) || token.data;
        }
        if (!bound) {
          token.descoped = token.data;
          token.data = map[name] = map[name] || renamer(name, token) || token.data;
        }
      }
      return tokens;
    }
    function defaultRenamer() {
      var k = 0;
      return function rename(name) {
        return name + "_" + (k++).toString(36);
      };
    }
    function getScope(tokens) {
      var scope = {};
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        if (token.declaration) {
          scope[token.scope] = scope[token.scope] || {};
          scope[token.scope][token.data] = token;
        }
      }
      return scope;
    }
  }
});

// node_modules/glsl-token-string/index.js
var require_glsl_token_string = __commonJS({
  "node_modules/glsl-token-string/index.js"(exports, module) {
    module.exports = toString;
    function toString(tokens) {
      var output = [];
      for (var i = 0; i < tokens.length; i++) {
        if (tokens[i].type === "eof")
          continue;
        output.push(tokens[i].data);
      }
      return output.join("");
    }
  }
});

// node_modules/glsl-token-functions/index.js
var require_glsl_token_functions = __commonJS({
  "node_modules/glsl-token-functions/index.js"(exports, module) {
    module.exports = functions;
    function functions(tokens) {
      var returnType = null;
      var defnName = null;
      var braceDepth = 0;
      var braceStart = 0;
      var defnStart = 0;
      var argFinish = 0;
      var argStart = 0;
      var output = [];
      var i, j, token;
      for (i = 0, j; i < tokens.length; i++) {
        token = tokens[i];
        if (token.data === "{") {
          if (braceDepth && braceDepth++)
            continue;
          j = findPrevious(i, findOp(")"), findOp());
          if (j < 0)
            continue;
          argFinish = j;
          j = findPrevious(j, findOp("("), findOp(")"));
          if (j < 0)
            continue;
          argStart = j;
          j = findPrevious(j, findGlyph);
          if (j < 0)
            continue;
          if (tokens[j].type !== "ident")
            continue;
          defnName = tokens[j].data;
          j = findPrevious(j, findGlyph);
          if (j < 0)
            continue;
          braceDepth = 1;
          braceStart = i;
          returnType = tokens[j].data;
          defnStart = j;
          var k = findPrevious(j, findGlyph);
          switch (tokens[k] && tokens[k].data) {
            case "lowp":
            case "highp":
            case "mediump":
              defnStart = k;
          }
        } else if (braceDepth && token.data === "}") {
          if (--braceDepth)
            continue;
          output.push({
            name: defnName,
            type: returnType,
            body: [braceStart + 1, i],
            args: [argStart, argFinish + 1],
            outer: [defnStart, i + 1]
          });
        }
      }
      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        if (token.data === ";") {
          j = findPrevious(i, findOp(")"), findOp());
          if (j < 0)
            continue;
          argFinish = j;
          j = findPrevious(j, findOp("("), findOp(")"));
          if (j < 0)
            continue;
          argStart = j;
          j = findPrevious(j, findGlyph);
          if (j < 0)
            continue;
          if (tokens[j].type !== "ident")
            continue;
          defnName = tokens[j].data;
          j = findPrevious(j, findGlyph);
          if (j < 0)
            continue;
          if (tokens[j].type === "operator")
            continue;
          if (tokens[j].data === "return")
            continue;
          returnType = tokens[j].data;
          output.push({
            name: defnName,
            type: returnType,
            body: false,
            args: [argStart, argFinish + 1],
            outer: [j, i + 1]
          });
        }
      }
      return output.sort(function(a, b) {
        return a.outer[0] - b.outer[0];
      });
      function findPrevious(start, match, bail) {
        for (var i2 = start - 1; i2 >= 0; i2--) {
          if (match(tokens[i2]))
            return i2;
          if (bail && bail(tokens[i2]))
            return -1;
        }
        return -1;
      }
    }
    function findOp(data) {
      return function(token) {
        return token.type === "operator" && (!data || token.data === data);
      };
    }
    function findGlyph(token) {
      return token.type !== "whitespace";
    }
  }
});

// node_modules/object-hash/dist/object_hash.js
var require_object_hash = __commonJS({
  "node_modules/object-hash/dist/object_hash.js"(exports, module) {
    !function(e) {
      var t;
      "object" == typeof exports ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : ("undefined" != typeof window ? t = window : "undefined" != typeof global ? t = global : "undefined" != typeof self && (t = self), t.objectHash = e());
    }(function() {
      return function r(o, i, u) {
        function s(n, e2) {
          if (!i[n]) {
            if (!o[n]) {
              var t = "function" == typeof __require && __require;
              if (!e2 && t)
                return t(n, true);
              if (a)
                return a(n, true);
              throw new Error("Cannot find module '" + n + "'");
            }
            e2 = i[n] = { exports: {} };
            o[n][0].call(e2.exports, function(e3) {
              var t2 = o[n][1][e3];
              return s(t2 || e3);
            }, e2, e2.exports, r, o, i, u);
          }
          return i[n].exports;
        }
        for (var a = "function" == typeof __require && __require, e = 0; e < u.length; e++)
          s(u[e]);
        return s;
      }({ 1: [function(w, b, m) {
        !function(e, n, s, c, d, h, p, g, y) {
          "use strict";
          var r = w("crypto");
          function t(e2, t2) {
            t2 = u(e2, t2);
            var n2;
            return void 0 === (n2 = "passthrough" !== t2.algorithm ? r.createHash(t2.algorithm) : new l()).write && (n2.write = n2.update, n2.end = n2.update), f(t2, n2).dispatch(e2), n2.update || n2.end(""), n2.digest ? n2.digest("buffer" === t2.encoding ? void 0 : t2.encoding) : (e2 = n2.read(), "buffer" !== t2.encoding ? e2.toString(t2.encoding) : e2);
          }
          (m = b.exports = t).sha1 = function(e2) {
            return t(e2);
          }, m.keys = function(e2) {
            return t(e2, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
          }, m.MD5 = function(e2) {
            return t(e2, { algorithm: "md5", encoding: "hex" });
          }, m.keysMD5 = function(e2) {
            return t(e2, { algorithm: "md5", encoding: "hex", excludeValues: true });
          };
          var o = r.getHashes ? r.getHashes().slice() : ["sha1", "md5"], i = (o.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
          function u(e2, t2) {
            var n2 = {};
            if (n2.algorithm = (t2 = t2 || {}).algorithm || "sha1", n2.encoding = t2.encoding || "hex", n2.excludeValues = !!t2.excludeValues, n2.algorithm = n2.algorithm.toLowerCase(), n2.encoding = n2.encoding.toLowerCase(), n2.ignoreUnknown = true === t2.ignoreUnknown, n2.respectType = false !== t2.respectType, n2.respectFunctionNames = false !== t2.respectFunctionNames, n2.respectFunctionProperties = false !== t2.respectFunctionProperties, n2.unorderedArrays = true === t2.unorderedArrays, n2.unorderedSets = false !== t2.unorderedSets, n2.unorderedObjects = false !== t2.unorderedObjects, n2.replacer = t2.replacer || void 0, n2.excludeKeys = t2.excludeKeys || void 0, void 0 === e2)
              throw new Error("Object argument required.");
            for (var r2 = 0; r2 < o.length; ++r2)
              o[r2].toLowerCase() === n2.algorithm.toLowerCase() && (n2.algorithm = o[r2]);
            if (-1 === o.indexOf(n2.algorithm))
              throw new Error('Algorithm "' + n2.algorithm + '"  not supported. supported values: ' + o.join(", "));
            if (-1 === i.indexOf(n2.encoding) && "passthrough" !== n2.algorithm)
              throw new Error('Encoding "' + n2.encoding + '"  not supported. supported values: ' + i.join(", "));
            return n2;
          }
          function a(e2) {
            if ("function" == typeof e2)
              return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e2));
          }
          function f(o2, t2, i2) {
            i2 = i2 || [];
            function u2(e2) {
              return t2.update ? t2.update(e2, "utf8") : t2.write(e2, "utf8");
            }
            return { dispatch: function(e2) {
              return this["_" + (null === (e2 = o2.replacer ? o2.replacer(e2) : e2) ? "null" : typeof e2)](e2);
            }, _object: function(t3) {
              var n2, e2 = Object.prototype.toString.call(t3), r2 = /\[object (.*)\]/i.exec(e2);
              r2 = (r2 = r2 ? r2[1] : "unknown:[" + e2 + "]").toLowerCase();
              if (0 <= (e2 = i2.indexOf(t3)))
                return this.dispatch("[CIRCULAR:" + e2 + "]");
              if (i2.push(t3), void 0 !== s && s.isBuffer && s.isBuffer(t3))
                return u2("buffer:"), u2(t3);
              if ("object" === r2 || "function" === r2 || "asyncfunction" === r2)
                return e2 = Object.keys(t3), o2.unorderedObjects && (e2 = e2.sort()), false === o2.respectType || a(t3) || e2.splice(0, 0, "prototype", "__proto__", "constructor"), o2.excludeKeys && (e2 = e2.filter(function(e3) {
                  return !o2.excludeKeys(e3);
                })), u2("object:" + e2.length + ":"), n2 = this, e2.forEach(function(e3) {
                  n2.dispatch(e3), u2(":"), o2.excludeValues || n2.dispatch(t3[e3]), u2(",");
                });
              if (!this["_" + r2]) {
                if (o2.ignoreUnknown)
                  return u2("[" + r2 + "]");
                throw new Error('Unknown object type "' + r2 + '"');
              }
              this["_" + r2](t3);
            }, _array: function(e2, t3) {
              t3 = void 0 !== t3 ? t3 : false !== o2.unorderedArrays;
              var n2 = this;
              if (u2("array:" + e2.length + ":"), !t3 || e2.length <= 1)
                return e2.forEach(function(e3) {
                  return n2.dispatch(e3);
                });
              var r2 = [], t3 = e2.map(function(e3) {
                var t4 = new l(), n3 = i2.slice();
                return f(o2, t4, n3).dispatch(e3), r2 = r2.concat(n3.slice(i2.length)), t4.read().toString();
              });
              return i2 = i2.concat(r2), t3.sort(), this._array(t3, false);
            }, _date: function(e2) {
              return u2("date:" + e2.toJSON());
            }, _symbol: function(e2) {
              return u2("symbol:" + e2.toString());
            }, _error: function(e2) {
              return u2("error:" + e2.toString());
            }, _boolean: function(e2) {
              return u2("bool:" + e2.toString());
            }, _string: function(e2) {
              u2("string:" + e2.length + ":"), u2(e2.toString());
            }, _function: function(e2) {
              u2("fn:"), a(e2) ? this.dispatch("[native]") : this.dispatch(e2.toString()), false !== o2.respectFunctionNames && this.dispatch("function-name:" + String(e2.name)), o2.respectFunctionProperties && this._object(e2);
            }, _number: function(e2) {
              return u2("number:" + e2.toString());
            }, _xml: function(e2) {
              return u2("xml:" + e2.toString());
            }, _null: function() {
              return u2("Null");
            }, _undefined: function() {
              return u2("Undefined");
            }, _regexp: function(e2) {
              return u2("regex:" + e2.toString());
            }, _uint8array: function(e2) {
              return u2("uint8array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _uint8clampedarray: function(e2) {
              return u2("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _int8array: function(e2) {
              return u2("int8array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _uint16array: function(e2) {
              return u2("uint16array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _int16array: function(e2) {
              return u2("int16array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _uint32array: function(e2) {
              return u2("uint32array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _int32array: function(e2) {
              return u2("int32array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _float32array: function(e2) {
              return u2("float32array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _float64array: function(e2) {
              return u2("float64array:"), this.dispatch(Array.prototype.slice.call(e2));
            }, _arraybuffer: function(e2) {
              return u2("arraybuffer:"), this.dispatch(new Uint8Array(e2));
            }, _url: function(e2) {
              return u2("url:" + e2.toString());
            }, _map: function(e2) {
              u2("map:");
              e2 = Array.from(e2);
              return this._array(e2, false !== o2.unorderedSets);
            }, _set: function(e2) {
              u2("set:");
              e2 = Array.from(e2);
              return this._array(e2, false !== o2.unorderedSets);
            }, _file: function(e2) {
              return u2("file:"), this.dispatch([e2.name, e2.size, e2.type, e2.lastModfied]);
            }, _blob: function() {
              if (o2.ignoreUnknown)
                return u2("[blob]");
              throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
            }, _domwindow: function() {
              return u2("domwindow");
            }, _bigint: function(e2) {
              return u2("bigint:" + e2.toString());
            }, _process: function() {
              return u2("process");
            }, _timer: function() {
              return u2("timer");
            }, _pipe: function() {
              return u2("pipe");
            }, _tcp: function() {
              return u2("tcp");
            }, _udp: function() {
              return u2("udp");
            }, _tty: function() {
              return u2("tty");
            }, _statwatcher: function() {
              return u2("statwatcher");
            }, _securecontext: function() {
              return u2("securecontext");
            }, _connection: function() {
              return u2("connection");
            }, _zlib: function() {
              return u2("zlib");
            }, _context: function() {
              return u2("context");
            }, _nodescript: function() {
              return u2("nodescript");
            }, _httpparser: function() {
              return u2("httpparser");
            }, _dataview: function() {
              return u2("dataview");
            }, _signal: function() {
              return u2("signal");
            }, _fsevent: function() {
              return u2("fsevent");
            }, _tlswrap: function() {
              return u2("tlswrap");
            } };
          }
          function l() {
            return { buf: "", write: function(e2) {
              this.buf += e2;
            }, end: function(e2) {
              this.buf += e2;
            }, read: function() {
              return this.buf;
            } };
          }
          m.writeToStream = function(e2, t2, n2) {
            return void 0 === n2 && (n2 = t2, t2 = {}), f(t2 = u(e2, t2), n2).dispatch(e2);
          };
        }.call(this, w("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
      }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(e, t, f) {
        !function(e2, t2, n, r, o, i, u, s, a) {
          !function(e3) {
            "use strict";
            var a2 = "undefined" != typeof Uint8Array ? Uint8Array : Array, t3 = "+".charCodeAt(0), n2 = "/".charCodeAt(0), r2 = "0".charCodeAt(0), o2 = "a".charCodeAt(0), i2 = "A".charCodeAt(0), u2 = "-".charCodeAt(0), s2 = "_".charCodeAt(0);
            function f2(e4) {
              e4 = e4.charCodeAt(0);
              return e4 === t3 || e4 === u2 ? 62 : e4 === n2 || e4 === s2 ? 63 : e4 < r2 ? -1 : e4 < r2 + 10 ? e4 - r2 + 26 + 26 : e4 < i2 + 26 ? e4 - i2 : e4 < o2 + 26 ? e4 - o2 + 26 : void 0;
            }
            e3.toByteArray = function(e4) {
              var t4, n3;
              if (0 < e4.length % 4)
                throw new Error("Invalid string. Length must be a multiple of 4");
              var r3 = e4.length, r3 = "=" === e4.charAt(r3 - 2) ? 2 : "=" === e4.charAt(r3 - 1) ? 1 : 0, o3 = new a2(3 * e4.length / 4 - r3), i3 = 0 < r3 ? e4.length - 4 : e4.length, u3 = 0;
              function s3(e5) {
                o3[u3++] = e5;
              }
              for (t4 = 0; t4 < i3; t4 += 4, 0)
                s3((16711680 & (n3 = f2(e4.charAt(t4)) << 18 | f2(e4.charAt(t4 + 1)) << 12 | f2(e4.charAt(t4 + 2)) << 6 | f2(e4.charAt(t4 + 3)))) >> 16), s3((65280 & n3) >> 8), s3(255 & n3);
              return 2 == r3 ? s3(255 & (n3 = f2(e4.charAt(t4)) << 2 | f2(e4.charAt(t4 + 1)) >> 4)) : 1 == r3 && (s3((n3 = f2(e4.charAt(t4)) << 10 | f2(e4.charAt(t4 + 1)) << 4 | f2(e4.charAt(t4 + 2)) >> 2) >> 8 & 255), s3(255 & n3)), o3;
            }, e3.fromByteArray = function(e4) {
              var t4, n3, r3, o3, i3 = e4.length % 3, u3 = "";
              function s3(e5) {
                return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e5);
              }
              for (t4 = 0, r3 = e4.length - i3; t4 < r3; t4 += 3)
                n3 = (e4[t4] << 16) + (e4[t4 + 1] << 8) + e4[t4 + 2], u3 += s3((o3 = n3) >> 18 & 63) + s3(o3 >> 12 & 63) + s3(o3 >> 6 & 63) + s3(63 & o3);
              switch (i3) {
                case 1:
                  u3 = (u3 += s3((n3 = e4[e4.length - 1]) >> 2)) + s3(n3 << 4 & 63) + "==";
                  break;
                case 2:
                  u3 = (u3 = (u3 += s3((n3 = (e4[e4.length - 2] << 8) + e4[e4.length - 1]) >> 10)) + s3(n3 >> 4 & 63)) + s3(n3 << 2 & 63) + "=";
              }
              return u3;
            };
          }(void 0 === f ? this.base64js = {} : f);
        }.call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
      }, { buffer: 3, lYpoI2: 11 }], 3: [function(O, e, H) {
        !function(e2, n, f, r, h, p, g, y, w) {
          var a = O("base64-js"), i = O("ieee754");
          function f(e3, t2, n2) {
            if (!(this instanceof f))
              return new f(e3, t2, n2);
            var r2, o2, i2, u2, s2 = typeof e3;
            if ("base64" === t2 && "string" == s2)
              for (e3 = (u2 = e3).trim ? u2.trim() : u2.replace(/^\s+|\s+$/g, ""); e3.length % 4 != 0; )
                e3 += "=";
            if ("number" == s2)
              r2 = j(e3);
            else if ("string" == s2)
              r2 = f.byteLength(e3, t2);
            else {
              if ("object" != s2)
                throw new Error("First argument needs to be a number, array or string.");
              r2 = j(e3.length);
            }
            if (f._useTypedArrays ? o2 = f._augment(new Uint8Array(r2)) : ((o2 = this).length = r2, o2._isBuffer = true), f._useTypedArrays && "number" == typeof e3.byteLength)
              o2._set(e3);
            else if (C(u2 = e3) || f.isBuffer(u2) || u2 && "object" == typeof u2 && "number" == typeof u2.length)
              for (i2 = 0; i2 < r2; i2++)
                f.isBuffer(e3) ? o2[i2] = e3.readUInt8(i2) : o2[i2] = e3[i2];
            else if ("string" == s2)
              o2.write(e3, 0, t2);
            else if ("number" == s2 && !f._useTypedArrays && !n2)
              for (i2 = 0; i2 < r2; i2++)
                o2[i2] = 0;
            return o2;
          }
          function b(e3, t2, n2, r2) {
            return f._charsWritten = c(function(e4) {
              for (var t3 = [], n3 = 0; n3 < e4.length; n3++)
                t3.push(255 & e4.charCodeAt(n3));
              return t3;
            }(t2), e3, n2, r2);
          }
          function m(e3, t2, n2, r2) {
            return f._charsWritten = c(function(e4) {
              for (var t3, n3, r3 = [], o2 = 0; o2 < e4.length; o2++)
                n3 = e4.charCodeAt(o2), t3 = n3 >> 8, n3 = n3 % 256, r3.push(n3), r3.push(t3);
              return r3;
            }(t2), e3, n2, r2);
          }
          function v(e3, t2, n2) {
            var r2 = "";
            n2 = Math.min(e3.length, n2);
            for (var o2 = t2; o2 < n2; o2++)
              r2 += String.fromCharCode(e3[o2]);
            return r2;
          }
          function o(e3, t2, n2, r2) {
            r2 || (d("boolean" == typeof n2, "missing or invalid endian"), d(null != t2, "missing offset"), d(t2 + 1 < e3.length, "Trying to read beyond buffer length"));
            var o2, r2 = e3.length;
            if (!(r2 <= t2))
              return n2 ? (o2 = e3[t2], t2 + 1 < r2 && (o2 |= e3[t2 + 1] << 8)) : (o2 = e3[t2] << 8, t2 + 1 < r2 && (o2 |= e3[t2 + 1])), o2;
          }
          function u(e3, t2, n2, r2) {
            r2 || (d("boolean" == typeof n2, "missing or invalid endian"), d(null != t2, "missing offset"), d(t2 + 3 < e3.length, "Trying to read beyond buffer length"));
            var o2, r2 = e3.length;
            if (!(r2 <= t2))
              return n2 ? (t2 + 2 < r2 && (o2 = e3[t2 + 2] << 16), t2 + 1 < r2 && (o2 |= e3[t2 + 1] << 8), o2 |= e3[t2], t2 + 3 < r2 && (o2 += e3[t2 + 3] << 24 >>> 0)) : (t2 + 1 < r2 && (o2 = e3[t2 + 1] << 16), t2 + 2 < r2 && (o2 |= e3[t2 + 2] << 8), t2 + 3 < r2 && (o2 |= e3[t2 + 3]), o2 += e3[t2] << 24 >>> 0), o2;
          }
          function _(e3, t2, n2, r2) {
            if (r2 || (d("boolean" == typeof n2, "missing or invalid endian"), d(null != t2, "missing offset"), d(t2 + 1 < e3.length, "Trying to read beyond buffer length")), !(e3.length <= t2))
              return r2 = o(e3, t2, n2, true), 32768 & r2 ? -1 * (65535 - r2 + 1) : r2;
          }
          function E(e3, t2, n2, r2) {
            if (r2 || (d("boolean" == typeof n2, "missing or invalid endian"), d(null != t2, "missing offset"), d(t2 + 3 < e3.length, "Trying to read beyond buffer length")), !(e3.length <= t2))
              return r2 = u(e3, t2, n2, true), 2147483648 & r2 ? -1 * (4294967295 - r2 + 1) : r2;
          }
          function I(e3, t2, n2, r2) {
            return r2 || (d("boolean" == typeof n2, "missing or invalid endian"), d(t2 + 3 < e3.length, "Trying to read beyond buffer length")), i.read(e3, t2, n2, 23, 4);
          }
          function A(e3, t2, n2, r2) {
            return r2 || (d("boolean" == typeof n2, "missing or invalid endian"), d(t2 + 7 < e3.length, "Trying to read beyond buffer length")), i.read(e3, t2, n2, 52, 8);
          }
          function s(e3, t2, n2, r2, o2) {
            o2 || (d(null != t2, "missing value"), d("boolean" == typeof r2, "missing or invalid endian"), d(null != n2, "missing offset"), d(n2 + 1 < e3.length, "trying to write beyond buffer length"), Y(t2, 65535));
            o2 = e3.length;
            if (!(o2 <= n2))
              for (var i2 = 0, u2 = Math.min(o2 - n2, 2); i2 < u2; i2++)
                e3[n2 + i2] = (t2 & 255 << 8 * (r2 ? i2 : 1 - i2)) >>> 8 * (r2 ? i2 : 1 - i2);
          }
          function l(e3, t2, n2, r2, o2) {
            o2 || (d(null != t2, "missing value"), d("boolean" == typeof r2, "missing or invalid endian"), d(null != n2, "missing offset"), d(n2 + 3 < e3.length, "trying to write beyond buffer length"), Y(t2, 4294967295));
            o2 = e3.length;
            if (!(o2 <= n2))
              for (var i2 = 0, u2 = Math.min(o2 - n2, 4); i2 < u2; i2++)
                e3[n2 + i2] = t2 >>> 8 * (r2 ? i2 : 3 - i2) & 255;
          }
          function B(e3, t2, n2, r2, o2) {
            o2 || (d(null != t2, "missing value"), d("boolean" == typeof r2, "missing or invalid endian"), d(null != n2, "missing offset"), d(n2 + 1 < e3.length, "Trying to write beyond buffer length"), F(t2, 32767, -32768)), e3.length <= n2 || s(e3, 0 <= t2 ? t2 : 65535 + t2 + 1, n2, r2, o2);
          }
          function L(e3, t2, n2, r2, o2) {
            o2 || (d(null != t2, "missing value"), d("boolean" == typeof r2, "missing or invalid endian"), d(null != n2, "missing offset"), d(n2 + 3 < e3.length, "Trying to write beyond buffer length"), F(t2, 2147483647, -2147483648)), e3.length <= n2 || l(e3, 0 <= t2 ? t2 : 4294967295 + t2 + 1, n2, r2, o2);
          }
          function U(e3, t2, n2, r2, o2) {
            o2 || (d(null != t2, "missing value"), d("boolean" == typeof r2, "missing or invalid endian"), d(null != n2, "missing offset"), d(n2 + 3 < e3.length, "Trying to write beyond buffer length"), D(t2, 34028234663852886e22, -34028234663852886e22)), e3.length <= n2 || i.write(e3, t2, n2, r2, 23, 4);
          }
          function x(e3, t2, n2, r2, o2) {
            o2 || (d(null != t2, "missing value"), d("boolean" == typeof r2, "missing or invalid endian"), d(null != n2, "missing offset"), d(n2 + 7 < e3.length, "Trying to write beyond buffer length"), D(t2, 17976931348623157e292, -17976931348623157e292)), e3.length <= n2 || i.write(e3, t2, n2, r2, 52, 8);
          }
          H.Buffer = f, H.SlowBuffer = f, H.INSPECT_MAX_BYTES = 50, f.poolSize = 8192, f._useTypedArrays = function() {
            try {
              var e3 = new ArrayBuffer(0), t2 = new Uint8Array(e3);
              return t2.foo = function() {
                return 42;
              }, 42 === t2.foo() && "function" == typeof t2.subarray;
            } catch (e4) {
              return false;
            }
          }(), f.isEncoding = function(e3) {
            switch (String(e3).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "raw":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          }, f.isBuffer = function(e3) {
            return !(null == e3 || !e3._isBuffer);
          }, f.byteLength = function(e3, t2) {
            var n2;
            switch (e3 += "", t2 || "utf8") {
              case "hex":
                n2 = e3.length / 2;
                break;
              case "utf8":
              case "utf-8":
                n2 = T(e3).length;
                break;
              case "ascii":
              case "binary":
              case "raw":
                n2 = e3.length;
                break;
              case "base64":
                n2 = M(e3).length;
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                n2 = 2 * e3.length;
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return n2;
          }, f.concat = function(e3, t2) {
            if (d(C(e3), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === e3.length)
              return new f(0);
            if (1 === e3.length)
              return e3[0];
            if ("number" != typeof t2)
              for (o2 = t2 = 0; o2 < e3.length; o2++)
                t2 += e3[o2].length;
            for (var n2 = new f(t2), r2 = 0, o2 = 0; o2 < e3.length; o2++) {
              var i2 = e3[o2];
              i2.copy(n2, r2), r2 += i2.length;
            }
            return n2;
          }, f.prototype.write = function(e3, t2, n2, r2) {
            isFinite(t2) ? isFinite(n2) || (r2 = n2, n2 = void 0) : (a2 = r2, r2 = t2, t2 = n2, n2 = a2), t2 = Number(t2) || 0;
            var o2, i2, u2, s2, a2 = this.length - t2;
            switch ((!n2 || a2 < (n2 = Number(n2))) && (n2 = a2), r2 = String(r2 || "utf8").toLowerCase()) {
              case "hex":
                o2 = function(e4, t3, n3, r3) {
                  n3 = Number(n3) || 0;
                  var o3 = e4.length - n3;
                  (!r3 || o3 < (r3 = Number(r3))) && (r3 = o3), d((o3 = t3.length) % 2 == 0, "Invalid hex string"), o3 / 2 < r3 && (r3 = o3 / 2);
                  for (var i3 = 0; i3 < r3; i3++) {
                    var u3 = parseInt(t3.substr(2 * i3, 2), 16);
                    d(!isNaN(u3), "Invalid hex string"), e4[n3 + i3] = u3;
                  }
                  return f._charsWritten = 2 * i3, i3;
                }(this, e3, t2, n2);
                break;
              case "utf8":
              case "utf-8":
                i2 = this, u2 = t2, s2 = n2, o2 = f._charsWritten = c(T(e3), i2, u2, s2);
                break;
              case "ascii":
              case "binary":
                o2 = b(this, e3, t2, n2);
                break;
              case "base64":
                i2 = this, u2 = t2, s2 = n2, o2 = f._charsWritten = c(M(e3), i2, u2, s2);
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                o2 = m(this, e3, t2, n2);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return o2;
          }, f.prototype.toString = function(e3, t2, n2) {
            var r2, o2, i2, u2, s2 = this;
            if (e3 = String(e3 || "utf8").toLowerCase(), t2 = Number(t2) || 0, (n2 = void 0 !== n2 ? Number(n2) : s2.length) === t2)
              return "";
            switch (e3) {
              case "hex":
                r2 = function(e4, t3, n3) {
                  var r3 = e4.length;
                  (!t3 || t3 < 0) && (t3 = 0);
                  (!n3 || n3 < 0 || r3 < n3) && (n3 = r3);
                  for (var o3 = "", i3 = t3; i3 < n3; i3++)
                    o3 += k(e4[i3]);
                  return o3;
                }(s2, t2, n2);
                break;
              case "utf8":
              case "utf-8":
                r2 = function(e4, t3, n3) {
                  var r3 = "", o3 = "";
                  n3 = Math.min(e4.length, n3);
                  for (var i3 = t3; i3 < n3; i3++)
                    e4[i3] <= 127 ? (r3 += N(o3) + String.fromCharCode(e4[i3]), o3 = "") : o3 += "%" + e4[i3].toString(16);
                  return r3 + N(o3);
                }(s2, t2, n2);
                break;
              case "ascii":
              case "binary":
                r2 = v(s2, t2, n2);
                break;
              case "base64":
                o2 = s2, u2 = n2, r2 = 0 === (i2 = t2) && u2 === o2.length ? a.fromByteArray(o2) : a.fromByteArray(o2.slice(i2, u2));
                break;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                r2 = function(e4, t3, n3) {
                  for (var r3 = e4.slice(t3, n3), o3 = "", i3 = 0; i3 < r3.length; i3 += 2)
                    o3 += String.fromCharCode(r3[i3] + 256 * r3[i3 + 1]);
                  return o3;
                }(s2, t2, n2);
                break;
              default:
                throw new Error("Unknown encoding");
            }
            return r2;
          }, f.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          }, f.prototype.copy = function(e3, t2, n2, r2) {
            if (t2 = t2 || 0, (r2 = r2 || 0 === r2 ? r2 : this.length) !== (n2 = n2 || 0) && 0 !== e3.length && 0 !== this.length) {
              d(n2 <= r2, "sourceEnd < sourceStart"), d(0 <= t2 && t2 < e3.length, "targetStart out of bounds"), d(0 <= n2 && n2 < this.length, "sourceStart out of bounds"), d(0 <= r2 && r2 <= this.length, "sourceEnd out of bounds"), r2 > this.length && (r2 = this.length);
              var o2 = (r2 = e3.length - t2 < r2 - n2 ? e3.length - t2 + n2 : r2) - n2;
              if (o2 < 100 || !f._useTypedArrays)
                for (var i2 = 0; i2 < o2; i2++)
                  e3[i2 + t2] = this[i2 + n2];
              else
                e3._set(this.subarray(n2, n2 + o2), t2);
            }
          }, f.prototype.slice = function(e3, t2) {
            var n2 = this.length;
            if (e3 = S(e3, n2, 0), t2 = S(t2, n2, n2), f._useTypedArrays)
              return f._augment(this.subarray(e3, t2));
            for (var r2 = t2 - e3, o2 = new f(r2, void 0, true), i2 = 0; i2 < r2; i2++)
              o2[i2] = this[i2 + e3];
            return o2;
          }, f.prototype.get = function(e3) {
            return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e3);
          }, f.prototype.set = function(e3, t2) {
            return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e3, t2);
          }, f.prototype.readUInt8 = function(e3, t2) {
            if (t2 || (d(null != e3, "missing offset"), d(e3 < this.length, "Trying to read beyond buffer length")), !(e3 >= this.length))
              return this[e3];
          }, f.prototype.readUInt16LE = function(e3, t2) {
            return o(this, e3, true, t2);
          }, f.prototype.readUInt16BE = function(e3, t2) {
            return o(this, e3, false, t2);
          }, f.prototype.readUInt32LE = function(e3, t2) {
            return u(this, e3, true, t2);
          }, f.prototype.readUInt32BE = function(e3, t2) {
            return u(this, e3, false, t2);
          }, f.prototype.readInt8 = function(e3, t2) {
            if (t2 || (d(null != e3, "missing offset"), d(e3 < this.length, "Trying to read beyond buffer length")), !(e3 >= this.length))
              return 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
          }, f.prototype.readInt16LE = function(e3, t2) {
            return _(this, e3, true, t2);
          }, f.prototype.readInt16BE = function(e3, t2) {
            return _(this, e3, false, t2);
          }, f.prototype.readInt32LE = function(e3, t2) {
            return E(this, e3, true, t2);
          }, f.prototype.readInt32BE = function(e3, t2) {
            return E(this, e3, false, t2);
          }, f.prototype.readFloatLE = function(e3, t2) {
            return I(this, e3, true, t2);
          }, f.prototype.readFloatBE = function(e3, t2) {
            return I(this, e3, false, t2);
          }, f.prototype.readDoubleLE = function(e3, t2) {
            return A(this, e3, true, t2);
          }, f.prototype.readDoubleBE = function(e3, t2) {
            return A(this, e3, false, t2);
          }, f.prototype.writeUInt8 = function(e3, t2, n2) {
            n2 || (d(null != e3, "missing value"), d(null != t2, "missing offset"), d(t2 < this.length, "trying to write beyond buffer length"), Y(e3, 255)), t2 >= this.length || (this[t2] = e3);
          }, f.prototype.writeUInt16LE = function(e3, t2, n2) {
            s(this, e3, t2, true, n2);
          }, f.prototype.writeUInt16BE = function(e3, t2, n2) {
            s(this, e3, t2, false, n2);
          }, f.prototype.writeUInt32LE = function(e3, t2, n2) {
            l(this, e3, t2, true, n2);
          }, f.prototype.writeUInt32BE = function(e3, t2, n2) {
            l(this, e3, t2, false, n2);
          }, f.prototype.writeInt8 = function(e3, t2, n2) {
            n2 || (d(null != e3, "missing value"), d(null != t2, "missing offset"), d(t2 < this.length, "Trying to write beyond buffer length"), F(e3, 127, -128)), t2 >= this.length || (0 <= e3 ? this.writeUInt8(e3, t2, n2) : this.writeUInt8(255 + e3 + 1, t2, n2));
          }, f.prototype.writeInt16LE = function(e3, t2, n2) {
            B(this, e3, t2, true, n2);
          }, f.prototype.writeInt16BE = function(e3, t2, n2) {
            B(this, e3, t2, false, n2);
          }, f.prototype.writeInt32LE = function(e3, t2, n2) {
            L(this, e3, t2, true, n2);
          }, f.prototype.writeInt32BE = function(e3, t2, n2) {
            L(this, e3, t2, false, n2);
          }, f.prototype.writeFloatLE = function(e3, t2, n2) {
            U(this, e3, t2, true, n2);
          }, f.prototype.writeFloatBE = function(e3, t2, n2) {
            U(this, e3, t2, false, n2);
          }, f.prototype.writeDoubleLE = function(e3, t2, n2) {
            x(this, e3, t2, true, n2);
          }, f.prototype.writeDoubleBE = function(e3, t2, n2) {
            x(this, e3, t2, false, n2);
          }, f.prototype.fill = function(e3, t2, n2) {
            if (t2 = t2 || 0, n2 = n2 || this.length, d("number" == typeof (e3 = "string" == typeof (e3 = e3 || 0) ? e3.charCodeAt(0) : e3) && !isNaN(e3), "value is not a number"), d(t2 <= n2, "end < start"), n2 !== t2 && 0 !== this.length) {
              d(0 <= t2 && t2 < this.length, "start out of bounds"), d(0 <= n2 && n2 <= this.length, "end out of bounds");
              for (var r2 = t2; r2 < n2; r2++)
                this[r2] = e3;
            }
          }, f.prototype.inspect = function() {
            for (var e3 = [], t2 = this.length, n2 = 0; n2 < t2; n2++)
              if (e3[n2] = k(this[n2]), n2 === H.INSPECT_MAX_BYTES) {
                e3[n2 + 1] = "...";
                break;
              }
            return "<Buffer " + e3.join(" ") + ">";
          }, f.prototype.toArrayBuffer = function() {
            if ("undefined" == typeof Uint8Array)
              throw new Error("Buffer.toArrayBuffer not supported in this browser");
            if (f._useTypedArrays)
              return new f(this).buffer;
            for (var e3 = new Uint8Array(this.length), t2 = 0, n2 = e3.length; t2 < n2; t2 += 1)
              e3[t2] = this[t2];
            return e3.buffer;
          };
          var t = f.prototype;
          function S(e3, t2, n2) {
            return "number" != typeof e3 ? n2 : t2 <= (e3 = ~~e3) ? t2 : 0 <= e3 || 0 <= (e3 += t2) ? e3 : 0;
          }
          function j(e3) {
            return (e3 = ~~Math.ceil(+e3)) < 0 ? 0 : e3;
          }
          function C(e3) {
            return (Array.isArray || function(e4) {
              return "[object Array]" === Object.prototype.toString.call(e4);
            })(e3);
          }
          function k(e3) {
            return e3 < 16 ? "0" + e3.toString(16) : e3.toString(16);
          }
          function T(e3) {
            for (var t2 = [], n2 = 0; n2 < e3.length; n2++) {
              var r2 = e3.charCodeAt(n2);
              if (r2 <= 127)
                t2.push(e3.charCodeAt(n2));
              else
                for (var o2 = n2, i2 = (55296 <= r2 && r2 <= 57343 && n2++, encodeURIComponent(e3.slice(o2, n2 + 1)).substr(1).split("%")), u2 = 0; u2 < i2.length; u2++)
                  t2.push(parseInt(i2[u2], 16));
            }
            return t2;
          }
          function M(e3) {
            return a.toByteArray(e3);
          }
          function c(e3, t2, n2, r2) {
            for (var o2 = 0; o2 < r2 && !(o2 + n2 >= t2.length || o2 >= e3.length); o2++)
              t2[o2 + n2] = e3[o2];
            return o2;
          }
          function N(e3) {
            try {
              return decodeURIComponent(e3);
            } catch (e4) {
              return String.fromCharCode(65533);
            }
          }
          function Y(e3, t2) {
            d("number" == typeof e3, "cannot write a non-number as a number"), d(0 <= e3, "specified a negative value for writing an unsigned value"), d(e3 <= t2, "value is larger than maximum value for type"), d(Math.floor(e3) === e3, "value has a fractional component");
          }
          function F(e3, t2, n2) {
            d("number" == typeof e3, "cannot write a non-number as a number"), d(e3 <= t2, "value larger than maximum allowed value"), d(n2 <= e3, "value smaller than minimum allowed value"), d(Math.floor(e3) === e3, "value has a fractional component");
          }
          function D(e3, t2, n2) {
            d("number" == typeof e3, "cannot write a non-number as a number"), d(e3 <= t2, "value larger than maximum allowed value"), d(n2 <= e3, "value smaller than minimum allowed value");
          }
          function d(e3, t2) {
            if (!e3)
              throw new Error(t2 || "Failed assertion");
          }
          f._augment = function(e3) {
            return e3._isBuffer = true, e3._get = e3.get, e3._set = e3.set, e3.get = t.get, e3.set = t.set, e3.write = t.write, e3.toString = t.toString, e3.toLocaleString = t.toString, e3.toJSON = t.toJSON, e3.copy = t.copy, e3.slice = t.slice, e3.readUInt8 = t.readUInt8, e3.readUInt16LE = t.readUInt16LE, e3.readUInt16BE = t.readUInt16BE, e3.readUInt32LE = t.readUInt32LE, e3.readUInt32BE = t.readUInt32BE, e3.readInt8 = t.readInt8, e3.readInt16LE = t.readInt16LE, e3.readInt16BE = t.readInt16BE, e3.readInt32LE = t.readInt32LE, e3.readInt32BE = t.readInt32BE, e3.readFloatLE = t.readFloatLE, e3.readFloatBE = t.readFloatBE, e3.readDoubleLE = t.readDoubleLE, e3.readDoubleBE = t.readDoubleBE, e3.writeUInt8 = t.writeUInt8, e3.writeUInt16LE = t.writeUInt16LE, e3.writeUInt16BE = t.writeUInt16BE, e3.writeUInt32LE = t.writeUInt32LE, e3.writeUInt32BE = t.writeUInt32BE, e3.writeInt8 = t.writeInt8, e3.writeInt16LE = t.writeInt16LE, e3.writeInt16BE = t.writeInt16BE, e3.writeInt32LE = t.writeInt32LE, e3.writeInt32BE = t.writeInt32BE, e3.writeFloatLE = t.writeFloatLE, e3.writeFloatBE = t.writeFloatBE, e3.writeDoubleLE = t.writeDoubleLE, e3.writeDoubleBE = t.writeDoubleBE, e3.fill = t.fill, e3.inspect = t.inspect, e3.toArrayBuffer = t.toArrayBuffer, e3;
          };
        }.call(this, O("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, O("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
      }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(c, d, e) {
        !function(e2, t, a, n, r, o, i, u, s) {
          var a = c("buffer").Buffer, f = 4, l = new a(f);
          l.fill(0);
          d.exports = { hash: function(e3, t2, n2, r2) {
            for (var o2 = t2(function(e4, t3) {
              e4.length % f != 0 && (n3 = e4.length + (f - e4.length % f), e4 = a.concat([e4, l], n3));
              for (var n3, r3 = [], o3 = t3 ? e4.readInt32BE : e4.readInt32LE, i3 = 0; i3 < e4.length; i3 += f)
                r3.push(o3.call(e4, i3));
              return r3;
            }(e3 = a.isBuffer(e3) ? e3 : new a(e3), r2), 8 * e3.length), t2 = r2, i2 = new a(n2), u2 = t2 ? i2.writeInt32BE : i2.writeInt32LE, s2 = 0; s2 < o2.length; s2++)
              u2.call(i2, o2[s2], 4 * s2, true);
            return i2;
          } };
        }.call(this, c("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 11 }], 5: [function(v, e, _) {
        !function(l, c, u, d, h, p, g, y, w) {
          var u = v("buffer").Buffer, e2 = v("./sha"), t = v("./sha256"), n = v("./rng"), b = { sha1: e2, sha256: t, md5: v("./md5") }, s = 64, a = new u(s);
          function r(e3, n2) {
            var r2 = b[e3 = e3 || "sha1"], o2 = [];
            return r2 || i("algorithm:", e3, "is not yet supported"), { update: function(e4) {
              return u.isBuffer(e4) || (e4 = new u(e4)), o2.push(e4), e4.length, this;
            }, digest: function(e4) {
              var t2 = u.concat(o2), t2 = n2 ? function(e5, t3, n3) {
                u.isBuffer(t3) || (t3 = new u(t3)), u.isBuffer(n3) || (n3 = new u(n3)), t3.length > s ? t3 = e5(t3) : t3.length < s && (t3 = u.concat([t3, a], s));
                for (var r3 = new u(s), o3 = new u(s), i2 = 0; i2 < s; i2++)
                  r3[i2] = 54 ^ t3[i2], o3[i2] = 92 ^ t3[i2];
                return n3 = e5(u.concat([r3, n3])), e5(u.concat([o3, n3]));
              }(r2, n2, t2) : r2(t2);
              return o2 = null, e4 ? t2.toString(e4) : t2;
            } };
          }
          function i() {
            var e3 = [].slice.call(arguments).join(" ");
            throw new Error([e3, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
          }
          a.fill(0), _.createHash = function(e3) {
            return r(e3);
          }, _.createHmac = r, _.randomBytes = function(e3, t2) {
            if (!t2 || !t2.call)
              return new u(n(e3));
            try {
              t2.call(this, void 0, new u(n(e3)));
            } catch (e4) {
              t2(e4);
            }
          };
          var o, f = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], m = function(e3) {
            _[e3] = function() {
              i("sorry,", e3, "is not implemented yet");
            };
          };
          for (o in f)
            m(f[o], o);
        }.call(this, v("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, v("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(w, b, e) {
        !function(e2, r, o, i, u, a, f, l, y) {
          var t = w("./helpers");
          function n(e3, t2) {
            e3[t2 >> 5] |= 128 << t2 % 32, e3[14 + (t2 + 64 >>> 9 << 4)] = t2;
            for (var n2 = 1732584193, r2 = -271733879, o2 = -1732584194, i2 = 271733878, u2 = 0; u2 < e3.length; u2 += 16) {
              var s2 = n2, a2 = r2, f2 = o2, l2 = i2, n2 = c(n2, r2, o2, i2, e3[u2 + 0], 7, -680876936), i2 = c(i2, n2, r2, o2, e3[u2 + 1], 12, -389564586), o2 = c(o2, i2, n2, r2, e3[u2 + 2], 17, 606105819), r2 = c(r2, o2, i2, n2, e3[u2 + 3], 22, -1044525330);
              n2 = c(n2, r2, o2, i2, e3[u2 + 4], 7, -176418897), i2 = c(i2, n2, r2, o2, e3[u2 + 5], 12, 1200080426), o2 = c(o2, i2, n2, r2, e3[u2 + 6], 17, -1473231341), r2 = c(r2, o2, i2, n2, e3[u2 + 7], 22, -45705983), n2 = c(n2, r2, o2, i2, e3[u2 + 8], 7, 1770035416), i2 = c(i2, n2, r2, o2, e3[u2 + 9], 12, -1958414417), o2 = c(o2, i2, n2, r2, e3[u2 + 10], 17, -42063), r2 = c(r2, o2, i2, n2, e3[u2 + 11], 22, -1990404162), n2 = c(n2, r2, o2, i2, e3[u2 + 12], 7, 1804603682), i2 = c(i2, n2, r2, o2, e3[u2 + 13], 12, -40341101), o2 = c(o2, i2, n2, r2, e3[u2 + 14], 17, -1502002290), n2 = d(n2, r2 = c(r2, o2, i2, n2, e3[u2 + 15], 22, 1236535329), o2, i2, e3[u2 + 1], 5, -165796510), i2 = d(i2, n2, r2, o2, e3[u2 + 6], 9, -1069501632), o2 = d(o2, i2, n2, r2, e3[u2 + 11], 14, 643717713), r2 = d(r2, o2, i2, n2, e3[u2 + 0], 20, -373897302), n2 = d(n2, r2, o2, i2, e3[u2 + 5], 5, -701558691), i2 = d(i2, n2, r2, o2, e3[u2 + 10], 9, 38016083), o2 = d(o2, i2, n2, r2, e3[u2 + 15], 14, -660478335), r2 = d(r2, o2, i2, n2, e3[u2 + 4], 20, -405537848), n2 = d(n2, r2, o2, i2, e3[u2 + 9], 5, 568446438), i2 = d(i2, n2, r2, o2, e3[u2 + 14], 9, -1019803690), o2 = d(o2, i2, n2, r2, e3[u2 + 3], 14, -187363961), r2 = d(r2, o2, i2, n2, e3[u2 + 8], 20, 1163531501), n2 = d(n2, r2, o2, i2, e3[u2 + 13], 5, -1444681467), i2 = d(i2, n2, r2, o2, e3[u2 + 2], 9, -51403784), o2 = d(o2, i2, n2, r2, e3[u2 + 7], 14, 1735328473), n2 = h(n2, r2 = d(r2, o2, i2, n2, e3[u2 + 12], 20, -1926607734), o2, i2, e3[u2 + 5], 4, -378558), i2 = h(i2, n2, r2, o2, e3[u2 + 8], 11, -2022574463), o2 = h(o2, i2, n2, r2, e3[u2 + 11], 16, 1839030562), r2 = h(r2, o2, i2, n2, e3[u2 + 14], 23, -35309556), n2 = h(n2, r2, o2, i2, e3[u2 + 1], 4, -1530992060), i2 = h(i2, n2, r2, o2, e3[u2 + 4], 11, 1272893353), o2 = h(o2, i2, n2, r2, e3[u2 + 7], 16, -155497632), r2 = h(r2, o2, i2, n2, e3[u2 + 10], 23, -1094730640), n2 = h(n2, r2, o2, i2, e3[u2 + 13], 4, 681279174), i2 = h(i2, n2, r2, o2, e3[u2 + 0], 11, -358537222), o2 = h(o2, i2, n2, r2, e3[u2 + 3], 16, -722521979), r2 = h(r2, o2, i2, n2, e3[u2 + 6], 23, 76029189), n2 = h(n2, r2, o2, i2, e3[u2 + 9], 4, -640364487), i2 = h(i2, n2, r2, o2, e3[u2 + 12], 11, -421815835), o2 = h(o2, i2, n2, r2, e3[u2 + 15], 16, 530742520), n2 = p(n2, r2 = h(r2, o2, i2, n2, e3[u2 + 2], 23, -995338651), o2, i2, e3[u2 + 0], 6, -198630844), i2 = p(i2, n2, r2, o2, e3[u2 + 7], 10, 1126891415), o2 = p(o2, i2, n2, r2, e3[u2 + 14], 15, -1416354905), r2 = p(r2, o2, i2, n2, e3[u2 + 5], 21, -57434055), n2 = p(n2, r2, o2, i2, e3[u2 + 12], 6, 1700485571), i2 = p(i2, n2, r2, o2, e3[u2 + 3], 10, -1894986606), o2 = p(o2, i2, n2, r2, e3[u2 + 10], 15, -1051523), r2 = p(r2, o2, i2, n2, e3[u2 + 1], 21, -2054922799), n2 = p(n2, r2, o2, i2, e3[u2 + 8], 6, 1873313359), i2 = p(i2, n2, r2, o2, e3[u2 + 15], 10, -30611744), o2 = p(o2, i2, n2, r2, e3[u2 + 6], 15, -1560198380), r2 = p(r2, o2, i2, n2, e3[u2 + 13], 21, 1309151649), n2 = p(n2, r2, o2, i2, e3[u2 + 4], 6, -145523070), i2 = p(i2, n2, r2, o2, e3[u2 + 11], 10, -1120210379), o2 = p(o2, i2, n2, r2, e3[u2 + 2], 15, 718787259), r2 = p(r2, o2, i2, n2, e3[u2 + 9], 21, -343485551), n2 = g(n2, s2), r2 = g(r2, a2), o2 = g(o2, f2), i2 = g(i2, l2);
            }
            return Array(n2, r2, o2, i2);
          }
          function s(e3, t2, n2, r2, o2, i2) {
            return g((t2 = g(g(t2, e3), g(r2, i2))) << o2 | t2 >>> 32 - o2, n2);
          }
          function c(e3, t2, n2, r2, o2, i2, u2) {
            return s(t2 & n2 | ~t2 & r2, e3, t2, o2, i2, u2);
          }
          function d(e3, t2, n2, r2, o2, i2, u2) {
            return s(t2 & r2 | n2 & ~r2, e3, t2, o2, i2, u2);
          }
          function h(e3, t2, n2, r2, o2, i2, u2) {
            return s(t2 ^ n2 ^ r2, e3, t2, o2, i2, u2);
          }
          function p(e3, t2, n2, r2, o2, i2, u2) {
            return s(n2 ^ (t2 | ~r2), e3, t2, o2, i2, u2);
          }
          function g(e3, t2) {
            var n2 = (65535 & e3) + (65535 & t2);
            return (e3 >> 16) + (t2 >> 16) + (n2 >> 16) << 16 | 65535 & n2;
          }
          b.exports = function(e3) {
            return t.hash(e3, n, 16);
          };
        }.call(this, w("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(e, l, t) {
        !function(e2, t2, n, r, o, i, u, s, f) {
          var a;
          l.exports = a || function(e3) {
            for (var t3, n2 = new Array(e3), r2 = 0; r2 < e3; r2++)
              0 == (3 & r2) && (t3 = 4294967296 * Math.random()), n2[r2] = t3 >>> ((3 & r2) << 3) & 255;
            return n2;
          };
        }.call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { buffer: 3, lYpoI2: 11 }], 8: [function(c, d, e) {
        !function(e2, t, n, r, o, s, a, f, l) {
          var i = c("./helpers");
          function u(l2, c2) {
            l2[c2 >> 5] |= 128 << 24 - c2 % 32, l2[15 + (c2 + 64 >> 9 << 4)] = c2;
            for (var e3, t2, n2, r2 = Array(80), o2 = 1732584193, i2 = -271733879, u2 = -1732584194, s2 = 271733878, d2 = -1009589776, h = 0; h < l2.length; h += 16) {
              for (var p = o2, g = i2, y = u2, w = s2, b = d2, a2 = 0; a2 < 80; a2++) {
                r2[a2] = a2 < 16 ? l2[h + a2] : v(r2[a2 - 3] ^ r2[a2 - 8] ^ r2[a2 - 14] ^ r2[a2 - 16], 1);
                var f2 = m(m(v(o2, 5), (f2 = i2, t2 = u2, n2 = s2, (e3 = a2) < 20 ? f2 & t2 | ~f2 & n2 : !(e3 < 40) && e3 < 60 ? f2 & t2 | f2 & n2 | t2 & n2 : f2 ^ t2 ^ n2)), m(m(d2, r2[a2]), (e3 = a2) < 20 ? 1518500249 : e3 < 40 ? 1859775393 : e3 < 60 ? -1894007588 : -899497514)), d2 = s2, s2 = u2, u2 = v(i2, 30), i2 = o2, o2 = f2;
              }
              o2 = m(o2, p), i2 = m(i2, g), u2 = m(u2, y), s2 = m(s2, w), d2 = m(d2, b);
            }
            return Array(o2, i2, u2, s2, d2);
          }
          function m(e3, t2) {
            var n2 = (65535 & e3) + (65535 & t2);
            return (e3 >> 16) + (t2 >> 16) + (n2 >> 16) << 16 | 65535 & n2;
          }
          function v(e3, t2) {
            return e3 << t2 | e3 >>> 32 - t2;
          }
          d.exports = function(e3) {
            return i.hash(e3, u, 20, true);
          };
        }.call(this, c("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(c, d, e) {
        !function(e2, t, n, r, u, s, a, f, l) {
          function b(e3, t2) {
            var n2 = (65535 & e3) + (65535 & t2);
            return (e3 >> 16) + (t2 >> 16) + (n2 >> 16) << 16 | 65535 & n2;
          }
          function o(e3, l2) {
            var c2, d2 = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), t2 = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), n2 = new Array(64);
            e3[l2 >> 5] |= 128 << 24 - l2 % 32, e3[15 + (l2 + 64 >> 9 << 4)] = l2;
            for (var r2, o2, h = 0; h < e3.length; h += 16) {
              for (var i2 = t2[0], u2 = t2[1], s2 = t2[2], p = t2[3], a2 = t2[4], g = t2[5], y = t2[6], w = t2[7], f2 = 0; f2 < 64; f2++)
                n2[f2] = f2 < 16 ? e3[f2 + h] : b(b(b((o2 = n2[f2 - 2], m(o2, 17) ^ m(o2, 19) ^ v(o2, 10)), n2[f2 - 7]), (o2 = n2[f2 - 15], m(o2, 7) ^ m(o2, 18) ^ v(o2, 3))), n2[f2 - 16]), c2 = b(b(b(b(w, m(o2 = a2, 6) ^ m(o2, 11) ^ m(o2, 25)), a2 & g ^ ~a2 & y), d2[f2]), n2[f2]), r2 = b(m(r2 = i2, 2) ^ m(r2, 13) ^ m(r2, 22), i2 & u2 ^ i2 & s2 ^ u2 & s2), w = y, y = g, g = a2, a2 = b(p, c2), p = s2, s2 = u2, u2 = i2, i2 = b(c2, r2);
              t2[0] = b(i2, t2[0]), t2[1] = b(u2, t2[1]), t2[2] = b(s2, t2[2]), t2[3] = b(p, t2[3]), t2[4] = b(a2, t2[4]), t2[5] = b(g, t2[5]), t2[6] = b(y, t2[6]), t2[7] = b(w, t2[7]);
            }
            return t2;
          }
          var i = c("./helpers"), m = function(e3, t2) {
            return e3 >>> t2 | e3 << 32 - t2;
          }, v = function(e3, t2) {
            return e3 >>> t2;
          };
          d.exports = function(e3) {
            return i.hash(e3, o, 32, true);
          };
        }.call(this, c("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
      }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(e, t, f) {
        !function(e2, t2, n, r, o, i, u, s, a) {
          f.read = function(e3, t3, n2, r2, o2) {
            var i2, u2, l = 8 * o2 - r2 - 1, c = (1 << l) - 1, d = c >> 1, s2 = -7, a2 = n2 ? o2 - 1 : 0, f2 = n2 ? -1 : 1, o2 = e3[t3 + a2];
            for (a2 += f2, i2 = o2 & (1 << -s2) - 1, o2 >>= -s2, s2 += l; 0 < s2; i2 = 256 * i2 + e3[t3 + a2], a2 += f2, s2 -= 8)
              ;
            for (u2 = i2 & (1 << -s2) - 1, i2 >>= -s2, s2 += r2; 0 < s2; u2 = 256 * u2 + e3[t3 + a2], a2 += f2, s2 -= 8)
              ;
            if (0 === i2)
              i2 = 1 - d;
            else {
              if (i2 === c)
                return u2 ? NaN : 1 / 0 * (o2 ? -1 : 1);
              u2 += Math.pow(2, r2), i2 -= d;
            }
            return (o2 ? -1 : 1) * u2 * Math.pow(2, i2 - r2);
          }, f.write = function(e3, t3, l, n2, r2, c) {
            var o2, i2, u2 = 8 * c - r2 - 1, s2 = (1 << u2) - 1, a2 = s2 >> 1, d = 23 === r2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : c - 1, h = n2 ? 1 : -1, c = t3 < 0 || 0 === t3 && 1 / t3 < 0 ? 1 : 0;
            for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (i2 = isNaN(t3) ? 1 : 0, o2 = s2) : (o2 = Math.floor(Math.log(t3) / Math.LN2), t3 * (n2 = Math.pow(2, -o2)) < 1 && (o2--, n2 *= 2), 2 <= (t3 += 1 <= o2 + a2 ? d / n2 : d * Math.pow(2, 1 - a2)) * n2 && (o2++, n2 /= 2), s2 <= o2 + a2 ? (i2 = 0, o2 = s2) : 1 <= o2 + a2 ? (i2 = (t3 * n2 - 1) * Math.pow(2, r2), o2 += a2) : (i2 = t3 * Math.pow(2, a2 - 1) * Math.pow(2, r2), o2 = 0)); 8 <= r2; e3[l + f2] = 255 & i2, f2 += h, i2 /= 256, r2 -= 8)
              ;
            for (o2 = o2 << r2 | i2, u2 += r2; 0 < u2; e3[l + f2] = 255 & o2, f2 += h, o2 /= 256, u2 -= 8)
              ;
            e3[l + f2 - h] |= 128 * c;
          };
        }.call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
      }, { buffer: 3, lYpoI2: 11 }], 11: [function(e, h, t) {
        !function(e2, t2, n, r, o, f, l, c, d) {
          var i, u, s;
          function a() {
          }
          (e2 = h.exports = {}).nextTick = (u = "undefined" != typeof window && window.setImmediate, s = "undefined" != typeof window && window.postMessage && window.addEventListener, u ? function(e3) {
            return window.setImmediate(e3);
          } : s ? (i = [], window.addEventListener("message", function(e3) {
            var t3 = e3.source;
            t3 !== window && null !== t3 || "process-tick" !== e3.data || (e3.stopPropagation(), 0 < i.length && i.shift()());
          }, true), function(e3) {
            i.push(e3), window.postMessage("process-tick", "*");
          }) : function(e3) {
            setTimeout(e3, 0);
          }), e2.title = "browser", e2.browser = true, e2.env = {}, e2.argv = [], e2.on = a, e2.addListener = a, e2.once = a, e2.off = a, e2.removeListener = a, e2.removeAllListeners = a, e2.emit = a, e2.binding = function(e3) {
            throw new Error("process.binding is not supported");
          }, e2.cwd = function() {
            return "/";
          }, e2.chdir = function(e3) {
            throw new Error("process.chdir is not supported");
          };
        }.call(this, e("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
      }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
    });
  }
});

// node_modules/lamina/index.js
var import_react = __toESM(require_react());
var import_glsl_tokenizer2 = __toESM(require_string());
var import_glsl_token_descope = __toESM(require_glsl_token_descope());
var import_glsl_token_string2 = __toESM(require_glsl_token_string());
var import_glsl_token_functions2 = __toESM(require_glsl_token_functions());

// node_modules/three-custom-shader-material/vanilla.js
var import_object_hash = __toESM(require_object_hash());
var import_glsl_tokenizer = __toESM(require_string());
var import_glsl_token_string = __toESM(require_glsl_token_string());
var import_glsl_token_functions = __toESM(require_glsl_token_functions());
var keywords = {
  position: "csm_Position",
  positionRaw: "csm_PositionRaw",
  pointSize: "csm_PointSize",
  fragColor: "csm_FragColor",
  diffuseColor: "csm_DiffuseColor",
  normal: "csm_Normal",
  roughness: "csm_Roughness",
  metalness: "csm_Metalness",
  emissive: "csm_Emissive"
};
var defaultPatchMap = {
  [`${keywords.normal}`]: {
    "#include <beginnormal_vertex>": `
    vec3 objectNormal = ${keywords.normal};
    #ifdef USE_TANGENT
	    vec3 objectTangent = vec3( tangent.xyz );
    #endif
    `
  },
  [`${keywords.position}`]: {
    "#include <begin_vertex>": `
    vec3 transformed = ${keywords.position};
  `
  },
  [`${keywords.positionRaw}`]: {
    "#include <begin_vertex>": `
    vec4 csm_positionUnprojected = ${keywords.positionRaw};
    mat4x4 csm_unprojectMatrix = projectionMatrix * modelViewMatrix;
    #ifdef USE_INSTANCING
      csm_unprojectMatrix = csm_unprojectMatrix * instanceMatrix;
    #endif
    csm_positionUnprojected = inverse(csm_unprojectMatrix) * csm_positionUnprojected;
    vec3 transformed = csm_positionUnprojected.xyz;
  `
  },
  [`${keywords.pointSize}`]: {
    "gl_PointSize = size;": `
    gl_PointSize = ${keywords.pointSize};
    `
  },
  [`${keywords.diffuseColor}`]: {
    "#include <color_fragment>": `
    #include <color_fragment>
    diffuseColor = ${keywords.diffuseColor};
  `
  },
  [`${keywords.fragColor}`]: {
    "#include <dithering_fragment>": `
    #include <dithering_fragment>
    gl_FragColor  = ${keywords.fragColor};
  `
  },
  [`${keywords.emissive}`]: {
    "vec3 totalEmissiveRadiance = emissive;": `
    vec3 totalEmissiveRadiance = ${keywords.emissive};
    `
  },
  [`${keywords.roughness}`]: {
    "#include <roughnessmap_fragment>": `
    #include <roughnessmap_fragment>
    roughnessFactor = ${keywords.roughness};
    `
  },
  [`${keywords.metalness}`]: {
    "#include <metalnessmap_fragment>": `
    #include <metalnessmap_fragment>
    metalnessFactor = ${keywords.metalness};
    `
  }
};
var shaderMaterial_PatchMap = {
  [`${keywords.position}`]: {
    "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );": `
    gl_Position = projectionMatrix * modelViewMatrix * vec4( ${keywords.position}, 1.0 );
  `
  },
  [`${keywords.positionRaw}`]: {
    "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );": `
    gl_Position = ${keywords.position};
  `
  },
  [`${keywords.diffuseColor}`]: {
    "gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );": `
    gl_FragColor = ${keywords.diffuseColor};
  `
  },
  [`${keywords.fragColor}`]: {
    "gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );": `
    gl_FragColor = ${keywords.fragColor};
  `
  }
};
var defaultDefinitions = `

#ifdef IS_VERTEX
    vec3 csm_Position = position;
    vec4 csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);
    vec3 csm_Normal = normal;
#else
    #if defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHNORMALMATERIAL
        vec4 csm_DiffuseColor = vec4(1., 0., 1., 1.);
        vec4 csm_FragColor = vec4(1., 0., 1., 1.);
    #else
        #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
            vec3 csm_Emissive = emissive;
            float csm_Roughness = roughness;
            float csm_Metalness = metalness;
        #endif
        
        #ifdef USE_MAP
            vec4 _csm_sampledDiffuseColor = texture2D(map, vUv);

            #ifdef DECODE_VIDEO_TEXTURE
            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)
            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);
            #endif

            vec4 csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
            vec4 csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
        #else
            vec4 csm_DiffuseColor = vec4(diffuse, opacity);
            vec4 csm_FragColor = vec4(diffuse, opacity);
        #endif
    #endif
#endif
`;
var replaceAll = (str, find, rep) => str.split(find).join(rep);
var escapeRegExpMatch = function(s) {
  return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
};
var isExactMatch = (str, match) => {
  return new RegExp(`\\b${escapeRegExpMatch(match)}\\b`).test(str);
};
function isConstructor(f) {
  try {
    new f();
  } catch (err) {
    if (err.message.indexOf("is not a constructor") >= 0) {
      return false;
    }
  }
  return true;
}
var CustomShaderMaterial = class extends Material {
  constructor({
    baseMaterial,
    fragmentShader,
    vertexShader,
    uniforms,
    patchMap,
    cacheKey,
    ...opts
  }) {
    let base;
    if (isConstructor(baseMaterial)) {
      base = new baseMaterial(opts);
    } else {
      base = baseMaterial;
      Object.assign(base, opts);
    }
    if (base.type === "RawShaderMaterial") {
      throw new Error("CustomShaderMaterial does not support RawShaderMaterial");
    }
    super();
    this.uniforms = uniforms || {};
    this._customPatchMap = patchMap || {};
    this._fs = fragmentShader || "";
    this._vs = vertexShader || "";
    this._cacheKey = cacheKey;
    this._base = baseMaterial;
    this._type = base.type;
    this._instanceID = MathUtils.generateUUID();
    for (const key in base) {
      let k = key;
      if (key.startsWith("_")) {
        k = key.split("_")[1];
      }
      if (this[k] === void 0)
        this[k] = 0;
      this[k] = base[k];
    }
    this.update({
      fragmentShader,
      vertexShader,
      uniforms,
      cacheKey
    });
  }
  update(opts) {
    const uniforms = (opts == null ? void 0 : opts.uniforms) || {};
    const fragmentShader = (opts == null ? void 0 : opts.fragmentShader) || this._fs;
    const vertexShader = (opts == null ? void 0 : opts.vertexShader) || this._vs;
    const serializedUniforms = Object.values(uniforms).reduce((prev, {
      value
    }) => {
      return prev + JSON.stringify(value);
    }, "");
    this.uuid = (opts == null ? void 0 : opts.cacheKey == null ? void 0 : opts.cacheKey()) || (0, import_object_hash.default)([fragmentShader, vertexShader, serializedUniforms, this._instanceID]);
    this.generateMaterial({
      fragmentShader,
      vertexShader,
      uniforms
    });
  }
  clone() {
    const c = new this.constructor({
      baseMaterial: this._base,
      fragmentShader: this._fs,
      vertexShader: this._vs,
      patchMap: this._customPatchMap,
      uniforms: this.uniforms,
      cacheKey: this._cacheKey
    });
    for (const key in this) {
      if (key === "uuid")
        continue;
      c[key] = this[key];
    }
    return c;
  }
  generateMaterial({
    fragmentShader,
    vertexShader,
    uniforms
  }) {
    const parsedFragmentShader = this.parseShader(fragmentShader);
    const parsedVertexShader = this.parseShader(vertexShader);
    this.uniforms = uniforms || {};
    this.customProgramCacheKey = () => {
      return this.uuid;
    };
    this.onBeforeCompile = (shader) => {
      if (parsedFragmentShader) {
        const patchedFragmentShader = this.patchShader(parsedFragmentShader, shader.fragmentShader);
        shader.fragmentShader = this.getMaterialDefine() + patchedFragmentShader;
      }
      if (parsedVertexShader) {
        const patchedVertexShader = this.patchShader(parsedVertexShader, shader.vertexShader);
        shader.vertexShader = "#define IS_VERTEX;\n" + patchedVertexShader;
        shader.vertexShader = this.getMaterialDefine() + shader.vertexShader;
      }
      shader.uniforms = {
        ...shader.uniforms,
        ...this.uniforms
      };
      this.uniforms = shader.uniforms;
    };
    this.needsUpdate = true;
  }
  getMaterialDefine() {
    return `#define IS_${this._type.toUpperCase()};
`;
  }
  getPatchMapForMaterial() {
    switch (this._type) {
      case "ShaderMaterial":
        return shaderMaterial_PatchMap;
      default:
        return defaultPatchMap;
    }
  }
  patchShader(customShader, shader) {
    let patchedShader = shader;
    const patchMap = {
      ...this.getPatchMapForMaterial(),
      ...this._customPatchMap
    };
    Object.keys(patchMap).forEach((name) => {
      Object.keys(patchMap[name]).forEach((key) => {
        if (isExactMatch(customShader.main, name)) {
          patchedShader = replaceAll(patchedShader, key, patchMap[name][key]);
        }
      });
    });
    patchedShader = patchedShader.replace("void main() {", `
          ${customShader.header}
          void main() {
            ${defaultDefinitions}
            ${customShader.main}
          `);
    patchedShader = customShader.defines + patchedShader;
    return patchedShader;
  }
  parseShader(shader) {
    if (!shader)
      return;
    const s = shader.replace(/\/\*\*(.*?)\*\/|\/\/(.*?)\n/gm, "");
    const tokens = (0, import_glsl_tokenizer.default)(s);
    const funcs = (0, import_glsl_token_functions.default)(tokens);
    const mainIndex = funcs.map((e) => {
      return e.name;
    }).indexOf("main");
    const variables = (0, import_glsl_token_string.default)(tokens.slice(0, mainIndex >= 0 ? funcs[mainIndex].outer[0] : void 0));
    const mainBody = mainIndex >= 0 ? this.getShaderFromIndex(tokens, funcs[mainIndex].body) : "";
    return {
      defines: "",
      header: variables,
      main: mainBody
    };
  }
  getShaderFromIndex(tokens, index) {
    return (0, import_glsl_token_string.default)(tokens.slice(index[0], index[1]));
  }
};

// node_modules/lamina/index.js
var import_client = __toESM(require_client());
function getUniform(value) {
  if (typeof value === "string") {
    return new Color(value).convertLinearToSRGB();
  }
  return value;
}
function getSpecialParameters(label) {
  switch (label) {
    case "alpha":
      return {
        min: 0,
        max: 1
      };
    case "scale":
      return {
        min: 0
      };
    case "map":
      return {
        image: void 0
      };
    default:
      return {};
  }
}
function getLayerMaterialArgs({
  color,
  alpha,
  lighting,
  name,
  ...rest
} = {}) {
  return [{
    color,
    alpha,
    lighting,
    name
  }, rest];
}
function isSerializableType(prop) {
  return prop instanceof Vector3 || prop instanceof Vector2 || prop instanceof Vector4 || prop instanceof Matrix3 || prop instanceof Matrix4;
}
function serializeProp(prop) {
  if (isSerializableType(prop)) {
    return prop.toArray();
  } else if (prop instanceof Color) {
    return "#" + prop.clone().convertLinearToSRGB().getHexString();
  } else if (prop instanceof Texture) {
    return prop.image.src;
  }
  return prop;
}
var BlendModes = {
  normal: "normal",
  add: "add",
  subtract: "subtract",
  multiply: "multiply",
  lighten: "lighten",
  darken: "darken",
  divide: "divide",
  overlay: "overlay",
  screen: "screen",
  softlight: "softlight",
  negation: "negation",
  reflect: "reflect"
};
var NoiseTypes = {
  perlin: "perlin",
  simplex: "simplex",
  cell: "cell",
  curl: "curl",
  white: "white"
};
var MappingTypes = {
  local: "local",
  world: "world",
  uv: "uv"
};
var ShadingTypes = {
  phong: MeshPhongMaterial,
  physical: MeshPhysicalMaterial,
  toon: MeshToonMaterial,
  basic: MeshBasicMaterial,
  lambert: MeshLambertMaterial,
  standard: MeshStandardMaterial
};
var Abstract = class {
  constructor(c, props, onParse) {
    this.uuid = MathUtils.generateUUID().replace(/-/g, "_");
    this.name = "LayerMaterial";
    this.mode = "normal";
    this.visible = true;
    const defaults = Object.getOwnPropertyNames(c).filter((e) => e.startsWith("u_"));
    const uniforms = defaults.reduce((a, v) => {
      var _Object$getOwnPropert;
      let value = (_Object$getOwnPropert = Object.getOwnPropertyDescriptor(c, v)) == null ? void 0 : _Object$getOwnPropert.value;
      if (isSerializableType(value) || value instanceof Color)
        value = value.clone();
      return {
        ...a,
        [v.slice(1)]: value
      };
    }, {});
    for (const key in uniforms) {
      const propName = key.split("_")[1];
      if ((props == null ? void 0 : props[propName]) !== void 0)
        uniforms[key] = props[propName];
    }
    if (props) {
      Object.keys(props).map((key) => {
        if (props[key] !== void 0) {
          this[key] = props[key];
        }
      });
    }
    this.uniforms = {};
    this.schema = [];
    const properties = {};
    Object.keys(uniforms).map((key) => {
      const propName = key.split("_")[1];
      this.uniforms[`u_${this.uuid}_${propName}`] = {
        value: getUniform(uniforms[key])
      };
      this.schema.push({
        value: uniforms[key],
        label: propName
      });
      properties[propName] = {
        set: (v) => {
          this.uniforms[`u_${this.uuid}_${propName}`].value = getUniform(v);
        },
        get: () => {
          return this.uniforms[`u_${this.uuid}_${propName}`].value;
        }
      };
    });
    if (props != null && props.name)
      this.name = props.name;
    if (props != null && props.mode)
      this.mode = props.mode;
    if (props != null && props.visible)
      this.visible = props.visible;
    Object.defineProperties(this, properties);
    this.vertexShader = "";
    this.fragmentShader = "";
    this.vertexVariables = "";
    this.fragmentVariables = "";
    this.onParse = onParse;
    this.buildShaders(c);
    this.schema.push({
      value: this.mode,
      label: "mode",
      options: Object.values(BlendModes)
    });
    this.schema.push({
      value: this.visible,
      label: "visible"
    });
  }
  buildShaders(constructor) {
    var _this$onParse;
    const shaders = Object.getOwnPropertyNames(constructor).filter((e) => e === "fragmentShader" || e === "vertexShader").reduce((a, v) => {
      var _Object$getOwnPropert2;
      return {
        ...a,
        [v]: (_Object$getOwnPropert2 = Object.getOwnPropertyDescriptor(constructor, v)) == null ? void 0 : _Object$getOwnPropert2.value
      };
    }, {});
    const tokens = {
      vert: (0, import_glsl_tokenizer2.default)(shaders.vertexShader || ""),
      frag: (0, import_glsl_tokenizer2.default)(shaders.fragmentShader || "")
    };
    const descoped = {
      vert: (0, import_glsl_token_descope.default)(tokens.vert, this.renameTokens.bind(this)),
      frag: (0, import_glsl_token_descope.default)(tokens.frag, this.renameTokens.bind(this))
    };
    const funcs = {
      vert: (0, import_glsl_token_functions2.default)(descoped.vert),
      frag: (0, import_glsl_token_functions2.default)(descoped.frag)
    };
    const mainIndex = {
      vert: funcs.vert.map((e) => {
        return e.name;
      }).indexOf("main"),
      frag: funcs.frag.map((e) => {
        return e.name;
      }).indexOf("main")
    };
    const variables = {
      vert: mainIndex.vert >= 0 ? (0, import_glsl_token_string2.default)(descoped.vert.slice(0, funcs.vert[mainIndex.vert].outer[0])) : "",
      frag: mainIndex.frag >= 0 ? (0, import_glsl_token_string2.default)(descoped.frag.slice(0, funcs.frag[mainIndex.frag].outer[0])) : ""
    };
    const funcBodies = {
      vert: mainIndex.vert >= 0 ? this.getShaderFromIndex(descoped.vert, funcs.vert[mainIndex.vert].body) : "",
      frag: mainIndex.frag >= 0 ? this.getShaderFromIndex(descoped.frag, funcs.frag[mainIndex.frag].body) : ""
    };
    this.vertexShader = this.processFinal(funcBodies.vert, true);
    this.fragmentShader = this.processFinal(funcBodies.frag);
    this.vertexVariables = variables.vert;
    this.fragmentVariables = variables.frag;
    (_this$onParse = this.onParse) == null ? void 0 : _this$onParse.call(this, this);
    this.schema = this.schema.filter((value, index) => {
      const _value = value.label;
      return index === this.schema.findIndex((obj) => {
        return obj.label === _value;
      });
    });
  }
  renameTokens(name) {
    if (name.startsWith("u_")) {
      const slice = name.slice(2);
      return `u_${this.uuid}_${slice}`;
    } else if (name.startsWith("v_")) {
      const slice = name.slice(2);
      return `v_${this.uuid}_${slice}`;
    } else if (name.startsWith("f_")) {
      const slice = name.slice(2);
      return `f_${this.uuid}_${slice}`;
    } else {
      return name;
    }
  }
  processFinal(shader, isVertex) {
    const s = shader.replace(/\sf_/gm, ` f_${this.uuid}_`).replace(/\(f_/gm, `(f_${this.uuid}_`);
    const returnValue = s.match(/^.*return.*$/gm);
    let sReplaced = s.replace(/^.*return.*$/gm, "");
    if (returnValue != null && returnValue[0]) {
      const returnVariable = returnValue[0].replace("return", "").trim().replace(";", "");
      const blendMode = this.getBlendMode(returnVariable, "lamina_finalColor");
      sReplaced += isVertex ? `lamina_finalPosition = ${returnVariable};` : `lamina_finalColor = ${blendMode};`;
    }
    return sReplaced;
  }
  getShaderFromIndex(tokens, index) {
    return (0, import_glsl_token_string2.default)(tokens.slice(index[0], index[1]));
  }
  getBlendMode(b, a) {
    switch (this.mode) {
      default:
      case "normal":
        return `lamina_blend_alpha(${a}, ${b}, ${b}.a)`;
      case "add":
        return `lamina_blend_add(${a}, ${b}, ${b}.a)`;
      case "subtract":
        return `lamina_blend_subtract(${a}, ${b}, ${b}.a)`;
      case "multiply":
        return `lamina_blend_multiply(${a}, ${b}, ${b}.a)`;
      case "lighten":
        return `lamina_blend_lighten(${a}, ${b}, ${b}.a)`;
      case "darken":
        return `lamina_blend_darken(${a}, ${b}, ${b}.a)`;
      case "divide":
        return `lamina_blend_divide(${a}, ${b}, ${b}.a)`;
      case "overlay":
        return `lamina_blend_overlay(${a}, ${b}, ${b}.a)`;
      case "screen":
        return `lamina_blend_screen(${a}, ${b}, ${b}.a)`;
      case "softlight":
        return `lamina_blend_softlight(${a}, ${b}, ${b}.a)`;
      case "reflect":
        return `lamina_blend_reflect(${a}, ${b}, ${b}.a)`;
      case "negation":
        return `lamina_blend_negation(${a}, ${b}, ${b}.a)`;
    }
  }
  getSchema() {
    const latestSchema = this.schema.map(({
      label,
      options,
      ...rest
    }) => {
      return {
        label,
        options,
        ...getSpecialParameters(label),
        ...rest,
        value: serializeProp(this[label])
      };
    });
    return latestSchema;
  }
  serialize() {
    const name = this.constructor.name.split("$")[0];
    let nonUniformPropKeys = Object.keys(this);
    nonUniformPropKeys = nonUniformPropKeys.filter((e) => !["uuid", "uniforms", "schema", "fragmentShader", "vertexShader", "fragmentVariables", "vertexVariables", "attribs", "events", "__r3f", "onParse"].includes(e));
    const nonUniformProps = {};
    nonUniformPropKeys.forEach((k) => {
      nonUniformProps[k] = this[k];
    });
    const props = {};
    for (const key in this.uniforms) {
      const name2 = key.replace(`u_${this.uuid}_`, "");
      props[name2] = serializeProp(this.uniforms[key].value);
    }
    return {
      constructor: name,
      properties: {
        ...props,
        ...nonUniformProps
      }
    };
  }
};
var Depth$1 = class extends Abstract {
  constructor(props) {
    super(Depth$1, {
      name: "Depth",
      ...props
    }, (self2) => {
      self2.schema.push({
        value: self2.mapping,
        label: "mapping",
        options: ["vector", "world", "camera"]
      });
      const mapping = Depth$1.getMapping(self2.uuid, self2.mapping);
      self2.fragmentShader = self2.fragmentShader.replace("lamina_mapping_template", mapping);
    });
    this.mapping = "vector";
  }
  static getMapping(uuid, type) {
    switch (type) {
      default:
      case "vector":
        return `length(v_${uuid}_worldPosition - u_${uuid}_origin)`;
      case "world":
        return `length(v_${uuid}_position - vec3(0.))`;
      case "camera":
        return `length(v_${uuid}_worldPosition - cameraPosition)`;
    }
  }
};
Depth$1.u_near = 2;
Depth$1.u_far = 10;
Depth$1.u_origin = new Vector3(0, 0, 0);
Depth$1.u_colorA = "white";
Depth$1.u_colorB = "black";
Depth$1.u_alpha = 1;
Depth$1.vertexShader = `
  varying vec3 v_worldPosition;
  varying vec3 v_position;

  void main() {
    v_worldPosition = (vec4(position, 1.0) * modelMatrix).xyz;
    v_position = position;
  }
  `;
Depth$1.fragmentShader = `   
    uniform float u_alpha;
    uniform float u_near;
    uniform float u_far;
    uniform float u_isVector;
    uniform vec3 u_origin;
    uniform vec3 u_colorA;
    uniform vec3 u_colorB;

    varying vec3 v_worldPosition;
    varying vec3 v_position;

    void main() {
      float f_dist = lamina_mapping_template;
      float f_depth = (f_dist - u_near) / (u_far - u_near);
			vec3 f_depthColor =  mix(u_colorB, u_colorA, 1.0 - clamp(f_depth, 0., 1.));
  
  
      return vec4(f_depthColor, u_alpha);
    }
  `;
var Color$1 = class extends Abstract {
  constructor(props) {
    super(Color$1, {
      name: "Color",
      ...props
    });
  }
};
Color$1.u_color = "red";
Color$1.u_alpha = 1;
Color$1.fragmentShader = `   
    uniform vec3 u_color;
    uniform float u_alpha;

    void main() {
      return vec4(u_color, u_alpha);
    }
  `;
var Noise$1 = class extends Abstract {
  constructor(props) {
    super(Noise$1, {
      name: "noise",
      ...props
    }, (self2) => {
      self2.schema.push({
        value: self2.type,
        label: "type",
        options: Object.values(NoiseTypes)
      });
      self2.schema.push({
        value: self2.mapping,
        label: "mapping",
        options: Object.values(MappingTypes)
      });
      const noiseFunc = Noise$1.getNoiseFunction(self2.type);
      const mapping = Noise$1.getMapping(self2.mapping);
      self2.vertexShader = self2.vertexShader.replace("lamina_mapping_template", mapping);
      self2.fragmentShader = self2.fragmentShader.replace("lamina_noise_template", noiseFunc);
    });
    this.type = "perlin";
    this.mapping = "local";
  }
  static getNoiseFunction(type) {
    switch (type) {
      default:
      case "perlin":
        return `lamina_noise_perlin`;
      case "simplex":
        return `lamina_noise_simplex`;
      case "cell":
        return `lamina_noise_worley`;
      case "white":
        return `lamina_noise_white`;
      case "curl":
        return `lamina_noise_swirl`;
    }
  }
  static getMapping(type) {
    switch (type) {
      default:
      case "local":
        return `position`;
      case "world":
        return `(modelMatrix * vec4(position,1.0)).xyz`;
      case "uv":
        return `vec3(uv, 0.)`;
    }
  }
};
Noise$1.u_colorA = "#666666";
Noise$1.u_colorB = "#666666";
Noise$1.u_colorC = "#FFFFFF";
Noise$1.u_colorD = "#FFFFFF";
Noise$1.u_alpha = 1;
Noise$1.u_scale = 1;
Noise$1.u_offset = new Vector3(0, 0, 0);
Noise$1.vertexShader = `
    varying vec3 v_position;

    void main() {
        v_position = lamina_mapping_template;
    }
  `;
Noise$1.fragmentShader = `   
    uniform vec3 u_colorA;
    uniform vec3 u_colorB;
    uniform vec3 u_colorC;
    uniform vec3 u_colorD;
    uniform vec3 u_offset;

    uniform float u_alpha;
    uniform float u_scale;

    varying vec3 v_position;


    void main() {
        float f_n = lamina_noise_template((v_position + u_offset) * u_scale);

        float f_step1 = 0.;
        float f_step2 = 0.2;
        float f_step3 = 0.6;
        float f_step4 = 1.;

        vec3 f_color = mix(u_colorA, u_colorB, smoothstep(f_step1, f_step2, f_n));
        f_color = mix(f_color, u_colorC, smoothstep(f_step2, f_step3, f_n));
        f_color = mix(f_color, u_colorD, smoothstep(f_step3, f_step4, f_n));

        return vec4(f_color, u_alpha);
    }
  `;
var Fresnel$1 = class extends Abstract {
  constructor(props) {
    super(Fresnel$1, {
      name: "Fresnel",
      ...props
    });
  }
};
Fresnel$1.u_color = "white";
Fresnel$1.u_alpha = 1;
Fresnel$1.u_bias = 0;
Fresnel$1.u_intensity = 1;
Fresnel$1.u_power = 2;
Fresnel$1.u_factor = 1;
Fresnel$1.vertexShader = `
    varying vec3 v_worldPosition;
    varying vec3 v_worldNormal;

    void main() {
        v_worldPosition = vec3(-viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2]);
        v_worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );
        
    }
  `;
Fresnel$1.fragmentShader = `   
    uniform vec3 u_color;
    uniform float u_alpha;
    uniform float u_bias;
    uniform float u_intensity;
    uniform float u_power;
    uniform float u_factor;

    varying vec3 v_worldPosition;
    varying vec3 v_worldNormal;

    void main() {
        float f_a = (u_factor  + dot(v_worldPosition, v_worldNormal));
        float f_fresnel = u_bias + u_intensity * pow(abs(f_a), u_power);

        f_fresnel = clamp(f_fresnel, 0.0, 1.0);
        return vec4(f_fresnel * u_color, u_alpha);
    }
  `;
var Gradient$1 = class extends Abstract {
  constructor(props) {
    super(Gradient$1, {
      name: "Gradient",
      ...props
    }, (self2) => {
      self2.schema.push({
        value: self2.axes,
        label: "axes",
        options: ["x", "y", "z"]
      });
      self2.schema.push({
        value: self2.mapping,
        label: "mapping",
        options: Object.values(MappingTypes)
      });
      const mapping = Gradient$1.getMapping(self2.mapping);
      self2.vertexShader = self2.vertexShader.replace("lamina_mapping_template", mapping || "local");
      self2.fragmentShader = self2.fragmentShader.replace("axes_template", self2.axes || "x");
    });
    this.axes = "x";
    this.mapping = "local";
  }
  static getMapping(type) {
    switch (type) {
      default:
      case "local":
        return `position`;
      case "world":
        return `(modelMatrix * vec4(position,1.0)).xyz`;
      case "uv":
        return `vec3(uv, 0.)`;
    }
  }
};
Gradient$1.u_colorA = "white";
Gradient$1.u_colorB = "black";
Gradient$1.u_alpha = 1;
Gradient$1.u_start = 1;
Gradient$1.u_end = -1;
Gradient$1.u_contrast = 1;
Gradient$1.vertexShader = `
		varying vec3 v_position;

		vod main() {
      v_position = lamina_mapping_template;
		}
  `;
Gradient$1.fragmentShader = `   
    uniform vec3 u_colorA;
    uniform vec3 u_colorB;
    uniform vec3 u_axis;
    uniform float u_alpha;
    uniform float u_start;
    uniform float u_end;
    uniform float u_contrast;

		varying vec3 v_position;

    void main() {

      float f_step = smoothstep(u_start, u_end, v_position.axes_template * u_contrast);
      vec3 f_color = mix(u_colorA, u_colorB, f_step);

      return vec4(f_color, u_alpha);
    }
  `;
var Matcap$1 = class extends Abstract {
  constructor(props) {
    super(Matcap$1, {
      name: "Matcap",
      ...props
    });
  }
};
Matcap$1.u_alpha = 1;
Matcap$1.u_map = void 0;
Matcap$1.vertexShader = `
    varying vec3 v_position;
    varying vec3 v_normal;
    
    void main() {
      v_position = normalize( vec3( modelViewMatrix * vec4( position, 1.0 ) ) );
      v_normal = normalize( normalMatrix * normal );
    }
    `;
Matcap$1.fragmentShader = ` 
		uniform sampler2D u_map;  
		uniform float u_alpha;  
		varying vec3 v_position;
		varying vec3 v_normal;

		
    void main() {
			vec3 f_r = reflect( v_position, v_normal );
			float f_m = 2. * sqrt( pow( f_r.x, 2. ) + pow( f_r.y, 2. ) + pow( f_r.z + 1., 2. ) );
			vec2 f_vN = f_r.xy / f_m + .5;

			vec3 f_base = texture2D(u_map, f_vN).rgb;

      return vec4(f_base, u_alpha);
    }
  `;
var Texture$1 = class extends Abstract {
  constructor(props) {
    super(Texture$1, {
      name: "Texture",
      ...props
    });
  }
};
Texture$1.u_alpha = 1;
Texture$1.u_map = void 0;
Texture$1.vertexShader = `
    varying vec2 v_uv;
    
    void main() {
        v_uv = uv;
    }
    `;
Texture$1.fragmentShader = ` 
		uniform sampler2D u_map;  
		uniform float u_alpha;  
		varying vec2 v_uv;

    void main() {
			vec4 f_color = texture2D(u_map, v_uv);
      return vec4(f_color.rgb, f_color.a * u_alpha);
    }
  `;
var Displace$1 = class extends Abstract {
  constructor(props) {
    super(Displace$1, {
      name: "Displace",
      ...props
    }, (self2) => {
      self2.schema.push({
        value: self2.type,
        label: "type",
        options: Object.values(NoiseTypes)
      });
      self2.schema.push({
        value: self2.mapping,
        label: "mapping",
        options: Object.values(MappingTypes)
      });
      const noiseFunc = Displace$1.getNoiseFunction(self2.type);
      const mapping = Displace$1.getMapping(self2.mapping);
      self2.vertexVariables = self2.vertexVariables.replace("lamina_mapping_template", mapping);
      self2.vertexVariables = self2.vertexVariables.replace("lamina_noise_template", noiseFunc);
    });
    this.type = "perlin";
    this.mapping = "local";
  }
  static getNoiseFunction(type) {
    switch (type) {
      default:
      case "perlin":
        return `lamina_noise_perlin`;
      case "simplex":
        return `lamina_noise_simplex`;
      case "cell":
        return `lamina_noise_worley`;
      case "white":
        return `lamina_noise_white`;
      case "curl":
        return `lamina_noise_swirl`;
    }
  }
  static getMapping(type) {
    switch (type) {
      default:
      case "local":
        return `p`;
      case "world":
        return `(modelMatrix * vec4(p,1.0)).xyz`;
      case "uv":
        return `vec3(uv, 0.)`;
    }
  }
};
Displace$1.u_strength = 1;
Displace$1.u_scale = 1;
Displace$1.u_offset = new Vector3(0, 0, 0);
Displace$1.vertexShader = `
       
      uniform float u_strength;
      uniform float u_scale;
      uniform vec3 u_offset;

      vec3 displace(vec3 p) {
				vec3 f_position = lamina_mapping_template;
        float f_n = lamina_noise_template((f_position + u_offset) * u_scale) * u_strength;
        vec3 f_newPosition = p + (f_n * normal);

				return f_newPosition;
      }

      
			vec3 orthogonal(vec3 v) {
  		  return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)
  		  : vec3(0.0, -v.z, v.y));
  		}
  		vec3 recalcNormals(vec3 newPos) {
  		  float offset = 0.001;
  		  vec3 tangent = orthogonal(normal);
  		  vec3 bitangent = normalize(cross(normal, tangent));
  		  vec3 neighbour1 = position + tangent * offset;
  		  vec3 neighbour2 = position + bitangent * offset;
  		  vec3 displacedNeighbour1 = displace(neighbour1);
  		  vec3 displacedNeighbour2 = displace(neighbour2);
  		  vec3 displacedTangent = displacedNeighbour1 - newPos;
  		  vec3 displacedBitangent = displacedNeighbour2 - newPos;
  		  return normalize(cross(displacedTangent, displacedBitangent));
  		}
  
  
      void main() {
       
				vec3 f_newPosition = displace(position);
        lamina_finalNormal = recalcNormals(f_newPosition);

        return f_newPosition;
      }
    `;
var Normal$1 = class extends Abstract {
  constructor(props) {
    super(Normal$1, {
      name: "Normal",
      ...props
    });
  }
};
Normal$1.u_alpha = 1;
Normal$1.u_direction = new Vector3(1, 1, 1);
Normal$1.vertexShader = `   
  varying vec3 v_normals; 

  void main() {
    v_normals = normal;
  }
`;
Normal$1.fragmentShader = `   
  	uniform float u_alpha;
  	uniform vec3 u_color;
  	uniform vec3 u_direction;

		varying vec3 v_normals;

    void main() {
			vec3 f_normalColor = vec3(1.);
      f_normalColor.x = v_normals.x * u_direction.x;
      f_normalColor.y = v_normals.y * u_direction.y;
      f_normalColor.z = v_normals.z * u_direction.z;

      return vec4(f_normalColor, u_alpha);
    }
  `;
var BlendModesChunk = `
vec4 lamina_blend_add(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4(min(x.xyz + y.xyz, 1.0) * opacity + x.xyz * (1.0 - opacity), x.a);

}
vec3 lamina_blend_alpha(const in vec3 x, const in vec3 y, const in float opacity) {

	return y * opacity + x * (1.0 - opacity);

}

vec4 lamina_blend_alpha(const in vec4 x, const in vec4 y, const in float opacity) {

	float a = min(y.a, opacity);

	return vec4(lamina_blend_alpha(x.rgb, y.rgb, a), x.a);

}
vec4 lamina_blend_average(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4((x.xyz + y.xyz) * 0.5 * opacity + x.xyz * (1.0 - opacity), x.a);

}
float lamina_blend_color_burn(const in float x, const in float y) {

	return (y == 0.0) ? y : max(1.0 - (1.0 - x) / y, 0.0);

}

vec4 lamina_blend_color_burn(const in vec4 x, const in vec4 y, const in float opacity) {

	vec4 z = vec4(
		lamina_blend_color_burn(x.r, y.r),
		lamina_blend_color_burn(x.g, y.g),
		lamina_blend_color_burn(x.b, y.b),
		lamina_blend_color_burn(x.a, y.a)
	);

	return vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);

}
float lamina_blend_color_dodge(const in float x, const in float y) {

	return (y == 1.0) ? y : min(x / (1.0 - y), 1.0);

}

vec4 lamina_blend_color_dodge(const in vec4 x, const in vec4 y, const in float opacity) {

	vec4 z = vec4(
		lamina_blend_color_dodge(x.r, y.r),
		lamina_blend_color_dodge(x.g, y.g),
		lamina_blend_color_dodge(x.b, y.b),
		lamina_blend_color_dodge(x.a, y.a)
	);

	return vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);

}
vec4 lamina_blend_darken(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4(min(x.xyz, y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);

}
vec4 lamina_blend_difference(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4(abs(x.xyz - y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);

}
float lamina_blend_divide(const in float x, const in float y) {

	return (y > 0.0) ? min(x / y, 1.0) : 1.0;

}

vec4 lamina_blend_divide(const in vec4 x, const in vec4 y, const in float opacity) {

	vec4 z = vec4(
		lamina_blend_divide(x.r, y.r),
		lamina_blend_divide(x.g, y.g),
		lamina_blend_divide(x.b, y.b),
		lamina_blend_divide(x.a, y.a)
	);

	return vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);

}
vec4 lamina_blend_exclusion(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4((x.xyz + y.xyz - 2.0 * x.xyz * y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);

}
vec4 lamina_blend_lighten(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4(max(x.xyz, y.xyz) * opacity + x.xyz * (1.0 - opacity), x.a);

}
vec4 lamina_blend_multiply(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4( x.xyz * y.xyz * opacity + x.xyz * (1.0 - opacity), x.a);

}
vec4 lamina_blend_negation(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4((1.0 - abs(1.0 - x.xyz - y.xyz)) * opacity + x.xyz * (1.0 - opacity), x.a);

}
vec4 lamina_blend_normal(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4(y.xyz * opacity + x.xyz * (1.0 - opacity), x.a);

}
float lamina_blend_overlay(const in float x, const in float y) {

	return (x < 0.5) ? (2.0 * x * y) : (1.0 - 2.0 * (1.0 - x) * (1.0 - y));

}

vec4 lamina_blend_overlay(const in vec4 x, const in vec4 y, const in float opacity) {

	vec4 z = vec4(
		lamina_blend_overlay(x.r, y.r),
		lamina_blend_overlay(x.g, y.g),
		lamina_blend_overlay(x.b, y.b),
		lamina_blend_overlay(x.a, y.a)
	);

	return vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);

}
float lamina_blend_reflect(const in float x, const in float y) {

	return (y == 1.0) ? y : min(x * x / (1.0 - y), 1.0);

}

vec4 lamina_blend_reflect(const in vec4 x, const in vec4 y, const in float opacity) {

	vec4 z = vec4(
		lamina_blend_reflect(x.r, y.r),
		lamina_blend_reflect(x.g, y.g),
		lamina_blend_reflect(x.b, y.b),
		lamina_blend_reflect(x.a, y.a)
	);

	return vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);

}
vec4 lamina_blend_screen(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4((1.0 - (1.0 - x.xyz) * (1.0 - y.xyz)) * opacity + x.xyz * (1.0 - opacity), x.a);

}
float lamina_blend_softlight(const in float x, const in float y) {

	return (y < 0.5) ?
		(2.0 * x * y + x * x * (1.0 - 2.0 * y)) :
		(sqrt(x) * (2.0 * y - 1.0) + 2.0 * x * (1.0 - y));

}

vec4 lamina_blend_softlight(const in vec4 x, const in vec4 y, const in float opacity) {

	vec4 z = vec4(
		lamina_blend_softlight(x.r, y.r),
		lamina_blend_softlight(x.g, y.g),
		lamina_blend_softlight(x.b, y.b),
		lamina_blend_softlight(x.a, y.a)
	);

	return vec4(z.xyz * opacity + x.xyz * (1.0 - opacity), x.a);

}
vec4 lamina_blend_subtract(const in vec4 x, const in vec4 y, const in float opacity) {

	return vec4(max(x.xyz + y.xyz - 1.0, 0.0) * opacity + x.xyz * (1.0 - opacity), x.a);

}

`;
var NoiseChunk = `

// From: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83
// Huge thanks to the creators of these algorithms

float lamina_noise_mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
vec4 lamina_noise_mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
vec4 lamina_noise_perm(vec4 x){return lamina_noise_mod289(((x * 34.0) + 1.0) * x);}
vec4 lamina_noise_permute(vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }
vec4 lamina_noise_taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }


float lamina_noise_white(vec2 p) {
  return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) *
               (0.1 + abs(sin(p.y * 13.0 + p.x))));
}

float lamina_noise_white(vec3 p) {
  return lamina_noise_white(p.xy);
}


vec3 lamina_noise_fade(vec3 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }

float lamina_noise_perlin(vec3 P) {
  vec3 Pi0 = floor(P);        // Integer part for indexing
  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
  Pi0 = mod(Pi0, 289.0);
  Pi1 = mod(Pi1, 289.0);
  vec3 Pf0 = fract(P);        // Fractional part for interpolation
  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  vec4 iy = vec4(Pi0.yy, Pi1.yy);
  vec4 iz0 = Pi0.zzzz;
  vec4 iz1 = Pi1.zzzz;

  vec4 ixy = lamina_noise_permute(lamina_noise_permute(ix) + iy);
  vec4 ixy0 = lamina_noise_permute(ixy + iz0);
  vec4 ixy1 = lamina_noise_permute(ixy + iz1);

  vec4 gx0 = ixy0 / 7.0;
  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
  gx0 = fract(gx0);
  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
  vec4 sz0 = step(gz0, vec4(0.0));
  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

  vec4 gx1 = ixy1 / 7.0;
  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
  gx1 = fract(gx1);
  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
  vec4 sz1 = step(gz1, vec4(0.0));
  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

  vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);
  vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);
  vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);
  vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);
  vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);
  vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);
  vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);
  vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);

  vec4 norm0 = lamina_noise_taylorInvSqrt(
      vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 *= norm0.x;
  g010 *= norm0.y;
  g100 *= norm0.z;
  g110 *= norm0.w;
  vec4 norm1 = lamina_noise_taylorInvSqrt(
      vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 *= norm1.x;
  g011 *= norm1.y;
  g101 *= norm1.z;
  g111 *= norm1.w;

  float n000 = dot(g000, Pf0);
  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
  float n111 = dot(g111, Pf1);

  vec3 fade_xyz = lamina_noise_fade(Pf0);
  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111),
                 fade_xyz.z);
  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
  return lamina_normalize(2.2 * n_xyz);
}

float lamina_noise_simplex(vec3 v) {
  const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);
  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

  // First corner
  vec3 i = floor(v + dot(v, C.yyy));
  vec3 x0 = v - i + dot(i, C.xxx);

  // Other corners
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min(g.xyz, l.zxy);
  vec3 i2 = max(g.xyz, l.zxy);

  //  x0 = x0 - 0. + 0.0 * C
  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
  vec3 x3 = x0 - 1. + 3.0 * C.xxx;

  // Permutations
  i = mod(i, 289.0);
  vec4 p = lamina_noise_permute(lamina_noise_permute(lamina_noise_permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y +
                             vec4(0.0, i1.y, i2.y, 1.0)) +
                    i.x + vec4(0.0, i1.x, i2.x, 1.0));

  // Gradients
  // ( N*N points uniformly over a square, mapped onto an octahedron.)
  float n_ = 1.0 / 7.0; // N=7
  vec3 ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); //  mod(p,N*N)

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_); // mod(j,N)

  vec4 x = x_ * ns.x + ns.yyyy;
  vec4 y = y_ * ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4(x.xy, y.xy);
  vec4 b1 = vec4(x.zw, y.zw);

  vec4 s0 = floor(b0) * 2.0 + 1.0;
  vec4 s1 = floor(b1) * 2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

  vec3 p0 = vec3(a0.xy, h.x);
  vec3 p1 = vec3(a0.zw, h.y);
  vec3 p2 = vec3(a1.xy, h.z);
  vec3 p3 = vec3(a1.zw, h.w);

  // Normalise gradients
  vec4 norm =
      lamina_noise_taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

  // Mix final noise value
  vec4 m =
      max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
  m = m * m;
  return lamina_normalize(42.0 *
         dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3))));
}

vec3 lamina_noise_simplex3(vec3 x) {
  float s = lamina_noise_simplex(vec3(x));
  float s1 = lamina_noise_simplex(vec3(x.y - 19.1, x.z + 33.4, x.x + 47.2));
  float s2 = lamina_noise_simplex(vec3(x.z + 74.2, x.x - 124.5, x.y + 99.4));
  vec3 c = vec3(s, s1, s2);
  return c;
}

vec3 lamina_noise_curl(vec3 p) {
  const float e = .1;
  vec3 dx = vec3(e, 0.0, 0.0);
  vec3 dy = vec3(0.0, e, 0.0);
  vec3 dz = vec3(0.0, 0.0, e);

  vec3 p_x0 = lamina_noise_simplex3(p - dx);
  vec3 p_x1 = lamina_noise_simplex3(p + dx);
  vec3 p_y0 = lamina_noise_simplex3(p - dy);
  vec3 p_y1 = lamina_noise_simplex3(p + dy);
  vec3 p_z0 = lamina_noise_simplex3(p - dz);
  vec3 p_z1 = lamina_noise_simplex3(p + dz);

  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;
  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;
  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;

  const float divisor = 1.0 / (2.0 * e);
  return normalize(vec3(x, y, z) * divisor);
}

vec3 lamina_permute(vec3 x) {
  return mod((34.0 * x + 1.0) * x, 289.0);
}

vec3 lamina_dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance) {
  return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);
}

// From: https://github.com/Erkaman/glsl-worley
float lamina_noise_worley(vec3 P) {
  float jitter = 1.;
  bool manhattanDistance = false; 

  float K = 0.142857142857; // 1/7
  float Ko = 0.428571428571; // 1/2-K/2
  float  K2 = 0.020408163265306; // 1/(7*7)
  float Kz = 0.166666666667; // 1/6
  float Kzo = 0.416666666667; // 1/2-1/6*2

	vec3 Pi = mod(floor(P), 289.0);
 	vec3 Pf = fract(P) - 0.5;

	vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);
	vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);
	vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);

	vec3 p = lamina_permute(Pi.x + vec3(-1.0, 0.0, 1.0));
	vec3 p1 = lamina_permute(p + Pi.y - 1.0);
	vec3 p2 = lamina_permute(p + Pi.y);
	vec3 p3 = lamina_permute(p + Pi.y + 1.0);

	vec3 p11 = lamina_permute(p1 + Pi.z - 1.0);
	vec3 p12 = lamina_permute(p1 + Pi.z);
	vec3 p13 = lamina_permute(p1 + Pi.z + 1.0);

	vec3 p21 = lamina_permute(p2 + Pi.z - 1.0);
	vec3 p22 = lamina_permute(p2 + Pi.z);
	vec3 p23 = lamina_permute(p2 + Pi.z + 1.0);

	vec3 p31 = lamina_permute(p3 + Pi.z - 1.0);
	vec3 p32 = lamina_permute(p3 + Pi.z);
	vec3 p33 = lamina_permute(p3 + Pi.z + 1.0);

	vec3 ox11 = fract(p11*K) - Ko;
	vec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;
	vec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed

	vec3 ox12 = fract(p12*K) - Ko;
	vec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;
	vec3 oz12 = floor(p12*K2)*Kz - Kzo;

	vec3 ox13 = fract(p13*K) - Ko;
	vec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;
	vec3 oz13 = floor(p13*K2)*Kz - Kzo;

	vec3 ox21 = fract(p21*K) - Ko;
	vec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;
	vec3 oz21 = floor(p21*K2)*Kz - Kzo;

	vec3 ox22 = fract(p22*K) - Ko;
	vec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;
	vec3 oz22 = floor(p22*K2)*Kz - Kzo;

	vec3 ox23 = fract(p23*K) - Ko;
	vec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;
	vec3 oz23 = floor(p23*K2)*Kz - Kzo;

	vec3 ox31 = fract(p31*K) - Ko;
	vec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;
	vec3 oz31 = floor(p31*K2)*Kz - Kzo;

	vec3 ox32 = fract(p32*K) - Ko;
	vec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;
	vec3 oz32 = floor(p32*K2)*Kz - Kzo;

	vec3 ox33 = fract(p33*K) - Ko;
	vec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;
	vec3 oz33 = floor(p33*K2)*Kz - Kzo;

	vec3 dx11 = Pfx + jitter*ox11;
	vec3 dy11 = Pfy.x + jitter*oy11;
	vec3 dz11 = Pfz.x + jitter*oz11;

	vec3 dx12 = Pfx + jitter*ox12;
	vec3 dy12 = Pfy.x + jitter*oy12;
	vec3 dz12 = Pfz.y + jitter*oz12;

	vec3 dx13 = Pfx + jitter*ox13;
	vec3 dy13 = Pfy.x + jitter*oy13;
	vec3 dz13 = Pfz.z + jitter*oz13;

	vec3 dx21 = Pfx + jitter*ox21;
	vec3 dy21 = Pfy.y + jitter*oy21;
	vec3 dz21 = Pfz.x + jitter*oz21;

	vec3 dx22 = Pfx + jitter*ox22;
	vec3 dy22 = Pfy.y + jitter*oy22;
	vec3 dz22 = Pfz.y + jitter*oz22;

	vec3 dx23 = Pfx + jitter*ox23;
	vec3 dy23 = Pfy.y + jitter*oy23;
	vec3 dz23 = Pfz.z + jitter*oz23;

	vec3 dx31 = Pfx + jitter*ox31;
	vec3 dy31 = Pfy.z + jitter*oy31;
	vec3 dz31 = Pfz.x + jitter*oz31;

	vec3 dx32 = Pfx + jitter*ox32;
	vec3 dy32 = Pfy.z + jitter*oy32;
	vec3 dz32 = Pfz.y + jitter*oz32;

	vec3 dx33 = Pfx + jitter*ox33;
	vec3 dy33 = Pfy.z + jitter*oy33;
	vec3 dz33 = Pfz.z + jitter*oz33;

	vec3 d11 = lamina_dist(dx11, dy11, dz11, manhattanDistance);
	vec3 d12 = lamina_dist(dx12, dy12, dz12, manhattanDistance);
	vec3 d13 = lamina_dist(dx13, dy13, dz13, manhattanDistance);
	vec3 d21 = lamina_dist(dx21, dy21, dz21, manhattanDistance);
	vec3 d22 = lamina_dist(dx22, dy22, dz22, manhattanDistance);
	vec3 d23 = lamina_dist(dx23, dy23, dz23, manhattanDistance);
	vec3 d31 = lamina_dist(dx31, dy31, dz31, manhattanDistance);
	vec3 d32 = lamina_dist(dx32, dy32, dz32, manhattanDistance);
	vec3 d33 = lamina_dist(dx33, dy33, dz33, manhattanDistance);

	vec3 d1a = min(d11, d12);
	d12 = max(d11, d12);
	d11 = min(d1a, d13); // Smallest now not in d12 or d13
	d13 = max(d1a, d13);
	d12 = min(d12, d13); // 2nd smallest now not in d13
	vec3 d2a = min(d21, d22);
	d22 = max(d21, d22);
	d21 = min(d2a, d23); // Smallest now not in d22 or d23
	d23 = max(d2a, d23);
	d22 = min(d22, d23); // 2nd smallest now not in d23
	vec3 d3a = min(d31, d32);
	d32 = max(d31, d32);
	d31 = min(d3a, d33); // Smallest now not in d32 or d33
	d33 = max(d3a, d33);
	d32 = min(d32, d33); // 2nd smallest now not in d33
	vec3 da = min(d11, d21);
	d21 = max(d11, d21);
	d11 = min(da, d31); // Smallest now in d11
	d31 = max(da, d31); // 2nd smallest now not in d31
	d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;
	d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest
	d12 = min(d12, d21); // 2nd smallest now not in d21
	d12 = min(d12, d22); // nor in d22
	d12 = min(d12, d31); // nor in d31
	d12 = min(d12, d32); // nor in d32
	d11.yz = min(d11.yz,d12.xy); // nor in d12.yz
	d11.y = min(d11.y,d12.z); // Only two more to go
	d11.y = min(d11.y,d11.z); // Done! (Phew!)

  vec2 F = sqrt(d11.xy);
	return F.x; // F1, F2

}

float lamina_noise_swirl(vec3 position) {
    float scale = 0.1;
    float freq = 4. * scale;
    float t = 1.;

    vec3 pos = (position * scale) + lamina_noise_curl(position * 7. * scale);

    float worley1 = 1. - lamina_noise_worley((pos * (freq * 2.)) +  (t * 2.));
    float worley2 = 1. - lamina_noise_worley((pos * (freq * 4.)) +  (t * 4.));
    float worley3 = 1. - lamina_noise_worley((pos * (freq * 8.)) +  (t * 8.));
    float worley4 = 1. - lamina_noise_worley((pos * (freq * 16.)) +  (t * 16.));
    
    float fbm1 = worley1 * .625 + worley2 * .25 + worley3 * .125;
    float fbm2 = worley2 * .625 + worley3 * .25 + worley4 * .125;
    float fbm3 = worley3 * .75 + worley4 * .25;

    vec3 curlWorleyFbm = vec3(fbm1, fbm2, fbm3);
    float curlWorley = curlWorleyFbm.r * .625 + curlWorleyFbm.g * .25 + 
        curlWorleyFbm.b * .125;

    return curlWorley;
}
  
  
`;
var HelpersChunk = `

float lamina_map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

float lamina_normalize(float v) { return lamina_map(v, -1.0, 1.0, 0.0, 1.0); }
`;
var LayerMaterial$1 = class extends CustomShaderMaterial {
  constructor({
    color,
    alpha,
    lighting,
    layers,
    name,
    ...props
  } = {}) {
    super({
      baseMaterial: ShadingTypes[lighting || "basic"],
      ...props
    });
    this.name = "LayerMaterial";
    this.layers = [];
    this.lighting = "basic";
    const _baseColor = color || "white";
    const _alpha = alpha != null ? alpha : 1;
    this.uniforms = {
      u_lamina_color: {
        value: typeof _baseColor === "string" ? new Color(_baseColor).convertSRGBToLinear() : _baseColor
      },
      u_lamina_alpha: {
        value: _alpha
      }
    };
    this.layers = layers || this.layers;
    this.lighting = lighting || this.lighting;
    this.name = name || this.name;
    this.refresh();
  }
  genShaders() {
    let vertexVariables = "";
    let fragmentVariables = "";
    let vertexShader = "";
    let fragmentShader = "";
    let uniforms = {};
    this.layers.filter((l) => l.visible).forEach((l) => {
      vertexVariables += l.vertexVariables + "\n";
      fragmentVariables += l.fragmentVariables + "\n";
      vertexShader += l.vertexShader + "\n";
      fragmentShader += l.fragmentShader + "\n";
      uniforms = {
        ...uniforms,
        ...l.uniforms
      };
    });
    uniforms = {
      ...uniforms,
      ...this.uniforms
    };
    return {
      uniforms,
      vertexShader: `
        ${HelpersChunk}
        ${NoiseChunk}
        ${vertexVariables}

        void main() {
          vec3 lamina_finalPosition = position;
          vec3 lamina_finalNormal = normal;

          ${vertexShader}

          csm_Position = lamina_finalPosition;
          csm_Normal = lamina_finalNormal;
        }
        `,
      fragmentShader: `
        ${HelpersChunk}
        ${NoiseChunk}
        ${BlendModesChunk}
        ${fragmentVariables}

        uniform vec3 u_lamina_color;
        uniform float u_lamina_alpha;

        void main() {
          vec4 lamina_finalColor = vec4(u_lamina_color, u_lamina_alpha);

          ${fragmentShader}

          csm_DiffuseColor = lamina_finalColor;
         
        }
        `
    };
  }
  refresh() {
    const {
      uniforms,
      fragmentShader,
      vertexShader
    } = this.genShaders();
    super.update({
      fragmentShader,
      vertexShader,
      uniforms
    });
  }
  serialize() {
    return {
      constructor: "LayerMaterial",
      properties: {
        color: this.color,
        alpha: this.alpha,
        name: this.name,
        lighting: this.lighting
      }
    };
  }
  set color(v) {
    var _this$uniforms, _this$uniforms$u_lami;
    if ((_this$uniforms = this.uniforms) != null && (_this$uniforms$u_lami = _this$uniforms.u_lamina_color) != null && _this$uniforms$u_lami.value)
      this.uniforms.u_lamina_color.value = typeof v === "string" ? new Color(v).convertSRGBToLinear() : v;
  }
  get color() {
    var _this$uniforms2, _this$uniforms2$u_lam;
    return (_this$uniforms2 = this.uniforms) == null ? void 0 : (_this$uniforms2$u_lam = _this$uniforms2.u_lamina_color) == null ? void 0 : _this$uniforms2$u_lam.value;
  }
  set alpha(v) {
    this.uniforms.u_lamina_alpha.value = v;
  }
  get alpha() {
    return this.uniforms.u_lamina_alpha.value;
  }
};
var LAYERS = Object.freeze({
  __proto__: null,
  LayerMaterial: LayerMaterial$1,
  Abstract,
  Depth: Depth$1,
  Color: Color$1,
  Noise: Noise$1,
  Fresnel: Fresnel$1,
  Gradient: Gradient$1,
  Matcap: Matcap$1,
  Texture: Texture$1,
  Displace: Displace$1,
  Normal: Normal$1
});
function getPropsFromLayer(layer) {
  const constructor = LAYERS[layer.constructor];
  const instance = new constructor();
  let props = "";
  Object.entries(layer.properties).forEach(([key, val]) => {
    var _constructor2;
    const defaultVal = (_constructor2 = constructor["u_" + key]) != null ? _constructor2 : instance[key];
    switch (key) {
      case "name":
        if (val !== layer.constructor)
          props += ` ${key}={${JSON.stringify(val)}}`;
        break;
      case "visible":
        if (!val)
          props += ` ${key}={${JSON.stringify(val)}}`;
        break;
      default:
        if (val !== defaultVal)
          props += ` ${key}={${JSON.stringify(val)}}`;
        break;
    }
  });
  return props;
}
function serializedLayersToJSX(layers, material) {
  const materialProps = getPropsFromLayer(material);
  const jsx = `
    <LayerMaterial${materialProps}>
      ${layers.map((layer) => {
    const props = getPropsFromLayer(layer);
    return `<${layer.constructor}${props} />`;
  }).join("\n	")}
    </LayerMaterial>
    `;
  return jsx;
}
function getJSPropsFromLayer(layer) {
  const constructor = LAYERS[layer.constructor];
  const instance = new constructor();
  let props = "	";
  let entries = Object.entries(layer.properties);
  entries.forEach(([key, val], idx) => {
    var _constructor;
    const eol = "\n		";
    if (key.includes("color")) {
      const v = typeof val === "string" ? val : "#" + val.getHexString();
      props += `${key}: ${JSON.stringify(v)},${eol}`;
    } else {
      const defaultVal = (_constructor = constructor["u_" + key]) != null ? _constructor : instance[key];
      switch (key) {
        case "name":
          if (val !== layer.constructor)
            props += `${key}: ${JSON.stringify(val)},${eol}`;
          break;
        case "visible":
          if (!val)
            props += `${key}:${JSON.stringify(val)},${eol}`;
          break;
        default:
          if (val !== defaultVal)
            props += `${key}: ${JSON.stringify(val)},${eol}`;
          break;
      }
    }
  });
  return props;
}
function serializedLayersToJS(layers, material) {
  const materialProps = getJSPropsFromLayer(material);
  const jsLayers = `${layers.map((l) => {
    return `new ${l.constructor}({
      ${getJSPropsFromLayer(l)}
      })`;
  }).join(",\n		")}`;
  const js = `
  new LayerMaterial({
    ${materialProps}
    layers: [
      ${jsLayers}
    ]
  })`;
  return js;
}
extend({
  LayerMaterial: LayerMaterial$1
});
function DynamicLeva({
  name,
  layers,
  store,
  setUpdate
}) {
  useControls(name, () => {
    const o = {};
    layers.forEach((layer, i) => {
      const n = `${layer.label} ~${i}`;
      o[n] = layer;
      o[n].onChange = () => setUpdate([`${name}.${n}`, layer.label]);
    });
    return o;
  }, {
    store
  }, [layers, name]);
  return null;
}
var DebugLayerMaterial = import_react.default.forwardRef(({
  children,
  ...props
}, forwardRef) => {
  var _ref$current, _ref$current2, _ref$current3;
  const ref = import_react.default.useRef(null);
  (0, import_react.useImperativeHandle)(forwardRef, () => ref.current);
  const store = useCreateStore();
  const [layers, setLayers] = import_react.default.useState({});
  const [path, setPath] = import_react.default.useState(["", ""]);
  const textureLoader = (0, import_react.useMemo)(() => new TextureLoader(), []);
  useControls({
    "Copy JSX": button(() => {
      const serialized = ref.current.layers.map((l) => l.serialize());
      const jsx = serializedLayersToJSX(serialized, ref.current.serialize());
      navigator.clipboard.writeText(jsx);
    }),
    "Copy JS": button(() => {
      const serialized = ref.current.layers.map((l) => l.serialize());
      const js = serializedLayersToJS(serialized, ref.current.serialize());
      navigator.clipboard.writeText(js);
    })
  }, {
    store
  });
  const {
    Lighting
  } = useControls("Base", {
    Color: {
      value: "#" + new Color(((_ref$current = ref.current) == null ? void 0 : _ref$current.color) || (props == null ? void 0 : props.color) || "white").convertLinearToSRGB().getHexString(),
      onChange: (v) => {
        ref.current.color = v;
      }
    },
    Alpha: {
      value: ((_ref$current2 = ref.current) == null ? void 0 : _ref$current2.alpha) || (props == null ? void 0 : props.alpha) || 1,
      min: 0,
      max: 1,
      onChange: (v) => {
        ref.current.alpha = v;
      }
    },
    Lighting: {
      value: ((_ref$current3 = ref.current) == null ? void 0 : _ref$current3.lighting) || (props == null ? void 0 : props.lighting) || "basic",
      options: Object.keys(ShadingTypes)
    }
  }, {
    store
  });
  const [args, otherProps] = (0, import_react.useMemo)(() => getLayerMaterialArgs({
    ...props,
    lighting: Lighting
  }), [props, Lighting]);
  import_react.default.useEffect(() => {
    const layers2 = ref.current.layers;
    const schema = {};
    layers2.forEach((layer, i) => {
      if (layer.getSchema)
        schema[`${layer.name} ~${i}`] = layer.getSchema();
    });
    setLayers(schema);
  }, [children]);
  import_react.default.useEffect(() => {
    const data = store.getData();
    const updatedData = data[path[0]];
    if (updatedData) {
      const split = path[0].split(".");
      const index = parseInt(split[0].split(" ~")[1]);
      const property = path[1];
      const id = ref.current.layers[index].uuid;
      const uniform = ref.current.uniforms[`u_${id}_${property}`];
      const layer = ref.current.layers[index];
      if (property !== "map") {
        layer[property] = updatedData.value;
        if (uniform) {
          uniform.value = getUniform(updatedData.value);
        } else {
          layer.buildShaders(layer.constructor);
          ref.current.refresh();
        }
      } else {
        (async () => {
          try {
            if (updatedData.value) {
              const t = await textureLoader.loadAsync(updatedData.value);
              layer[property] = t;
              uniform.value = t;
            } else {
              layer[property] = void 0;
              uniform.value = void 0;
            }
          } catch (error) {
            console.error(error);
          }
        })();
      }
    }
  }, [path]);
  import_react.default.useLayoutEffect(() => {
    ref.current.layers = ref.current.__r3f.objects;
    ref.current.refresh();
  }, [children, args]);
  import_react.default.useLayoutEffect(() => {
    const root = document.body.querySelector("#root");
    const div = document.createElement("div");
    if (root) {
      root.appendChild(div);
      const levaRoot = (0, import_client.createRoot)(div);
      levaRoot.render(import_react.default.createElement(LevaPanel, {
        titleBar: {
          title: props.name || ref.current.name
        },
        store
      }));
    }
    return () => {
      div.remove();
    };
  }, [props.name]);
  return import_react.default.createElement(import_react.default.Fragment, null, Object.entries(layers).map(([name, layers2], i) => import_react.default.createElement(DynamicLeva, {
    key: `${name} ~${i}`,
    name,
    layers: layers2,
    store,
    setUpdate: setPath
  })), import_react.default.createElement("layerMaterial", _extends({
    args: [args],
    ref
  }, otherProps), children));
});
extend({
  LayerMaterial: LayerMaterial$1,
  Depth_: Depth$1,
  Color_: Color$1,
  Noise_: Noise$1,
  Fresnel_: Fresnel$1,
  Gradient_: Gradient$1,
  Matcap_: Matcap$1,
  Texture_: Texture$1,
  Displace_: Displace$1,
  Normal_: Normal$1
});
var LayerMaterial = import_react.default.forwardRef(({
  children,
  ...props
}, forwardRef) => {
  const ref = import_react.default.useRef(null);
  (0, import_react.useImperativeHandle)(forwardRef, () => ref.current);
  import_react.default.useLayoutEffect(() => {
    ref.current.layers = ref.current.__r3f.objects;
    ref.current.refresh();
  }, [children]);
  const [args, otherProps] = (0, import_react.useMemo)(() => getLayerMaterialArgs(props), [props]);
  return import_react.default.createElement("layerMaterial", _extends({
    args: [args],
    ref
  }, otherProps), children);
});
function getNonUniformArgs(props) {
  return [{
    mode: props == null ? void 0 : props.mode,
    visible: props == null ? void 0 : props.visible,
    type: props == null ? void 0 : props.type,
    mapping: props == null ? void 0 : props.mapping,
    map: props == null ? void 0 : props.map,
    axes: props == null ? void 0 : props.axes
  }];
}
var Depth = import_react.default.forwardRef((props, forwardRef) => {
  return import_react.default.createElement("depth_", _extends({
    args: getNonUniformArgs(props),
    ref: forwardRef
  }, props));
});
var Color2 = import_react.default.forwardRef((props, ref) => {
  return import_react.default.createElement("color_", _extends({
    ref,
    args: getNonUniformArgs(props)
  }, props));
});
var Noise = import_react.default.forwardRef((props, ref) => {
  return import_react.default.createElement("noise_", _extends({
    ref,
    args: getNonUniformArgs(props)
  }, props));
});
var Fresnel = import_react.default.forwardRef((props, ref) => {
  return import_react.default.createElement("fresnel_", _extends({
    ref,
    args: getNonUniformArgs(props)
  }, props));
});
var Gradient = import_react.default.forwardRef((props, ref) => {
  return import_react.default.createElement("gradient_", _extends({
    ref,
    args: getNonUniformArgs(props)
  }, props));
});
var Matcap = import_react.default.forwardRef((props, ref) => {
  return import_react.default.createElement("matcap_", _extends({
    ref,
    args: getNonUniformArgs(props)
  }, props));
});
var Texture2 = import_react.default.forwardRef((props, ref) => {
  return import_react.default.createElement("texture_", _extends({
    ref,
    args: getNonUniformArgs(props)
  }, props));
});
var Displace = import_react.default.forwardRef((props, ref) => {
  return import_react.default.createElement("displace_", _extends({
    ref,
    args: getNonUniformArgs(props)
  }, props));
});
var Normal = import_react.default.forwardRef((props, ref) => {
  return import_react.default.createElement("normal_", _extends({
    ref,
    args: getNonUniformArgs(props)
  }, props));
});
export {
  Color2 as Color,
  DebugLayerMaterial,
  Depth,
  Displace,
  Fresnel,
  Gradient,
  LayerMaterial,
  Matcap,
  Noise,
  Normal,
  Texture2 as Texture
};
//# sourceMappingURL=lamina.js.map
