
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>motion</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	</head>
	<body>

		
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.js"></script>

		<script type="module">
			import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.146.0/examples/jsm/webxr/ARButton.js';
			let scene; 
			let camera;
			let renderer;
			let cube;
			let controller;

			let startScale = getRandomInt(4);
			let endScale = getRandomInt(4);
			let startColor = new THREE.Color(Math.random(),Math.random(),Math.random())
			let endColor = new THREE.Color(Math.random(),Math.random(),Math.random())

			// start recording! 
			function startRecording() {
				const chunks = []; // here we will store our recorded media chunks (Blobs)
				const stream = canvas.captureStream(); // grab our canvas MediaStream
				var options;
				var rec;
				try { //this works for chrome
					options = {
						mimeType: 'video/webm',
						videoBitsPerSecond : 8000000
					};
					rec = new MediaRecorder(stream, options);
					// every time the recorder has new data, we will store it in our array
					rec.ondataavailable = e => chunks.push(e.data);
					// only when the recorder stops, we construct a complete Blob from all the chunks
					rec.onstop = e => exportVid(new Blob(chunks, {type: 'vid/webm'}),'.webm');
				}
				catch (err1) {
					try { //this works for safari
						options = {
							mimeType: 'video/mp4',
							videoBitsPerSecond : 8000000
						};
						// Fallback for iOS
						rec = new MediaRecorder(stream, options);
						// every time the recorder has new data, we will store it in our array
						rec.ondataavailable = e => chunks.push(e.data);
						// only when the recorder stops, we construct a complete Blob from all the chunks
						rec.onstop = e => exportVid(new Blob(chunks, {type: 'vid/mp4'}),'.mp4');
					}
					catch (err2) {
						// If fallback doesn't work either. Log / process errors.
						console.error({err1});
						console.error({err2})
					}
				}
				
				rec.start(); //start the recording
				setTimeout(()=>rec.stop(), 3000); // stop recording in 3s 
			}

			//export the video - let the user download
			function exportVid(blob,extension) {
				const link = document.createElement( 'a' );
				link.href = URL.createObjectURL( blob );
				link.download = 'motion' + extension;
				link.dispatchEvent( new MouseEvent( 'click' ) );
			}

			let numFrames = 0 
			function getRandomInt(max) {
				return Math.ceil(Math.random() * max);
			}

			function easeOutCirc(x) {
				return Math.sqrt(1 - Math.pow(x - 1, 2));
			}

			function mix(a,b,val) {
				let alpha = easeOutCirc(val)
				return a + (b-a)*alpha;
			}

			function mixColor(col1,col2,val) {
				let alpha = easeOutCirc(val)
				let r = mix(col1.r,col2.r,val);
				let g = mix(col1.g,col2.g,val);
				let b = mix(col1.b,col2.b,val);
				return new THREE.Color(r,g,b);
			}

			function vertexShader() {
			return `
				varying vec3 vUv; 

				void main() {
				vUv = position; 

				vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
				gl_Position = projectionMatrix * modelViewPosition; 
				}
			`
			}
			// function easingCurves(index,a,b,val) {
				
			// }

			init();
			animate();
			function init() {
				scene = new THREE.Scene();
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

				renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true} );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.xr.enabled = true
				document.body.appendChild( renderer.domElement );

				document.body.appendChild( ARButton.createButton( renderer ) );

				const geometry = new THREE.BoxGeometry( 1, 1, 1 );
				const material = new THREE.MeshBasicMaterial( { color: '#ffffff'} )
				
				material.color = new THREE.Color(1,0,0);

				cube = new THREE.Mesh( geometry, material );
				scene.add( cube );

				controller = renderer.xr.getController( 0 );
				// controller.addEventListener( 'selectstart', onSelectStart );
				// controller.addEventListener( 'selectend', onSelectEnd );
				controller.userData.skipFrames = 0;
				
				scene.add( controller );

				camera.position.z = 5;
			}

			function animate(time) {
				renderer.setAnimationLoop( animate );

				numFrames += 1

				let alpha = numFrames / 100;

				cube.scale.x = mix(startScale,endScale,alpha);
				// cube.scale.y = mix(startScale,endScale,alpha);
				// cube.scale.z = mix(startScale,endScale,alpha);

				cube.material.color = mixColor(startColor,endColor,alpha);

				if (alpha == 1) {
					numFrames = 0
					startScale = endScale 
					endScale = getRandomInt(4)
					startColor = endColor
					endColor = new THREE.Color(Math.random(),Math.random(),Math.random())
				}

				// console.log(numFrames)
				cube.rotation.x += 0.003;
				cube.rotation.y += 0.003;
				cube.rotation.z += 0.003;


				if (renderer.xr.isPresenting) {
					renderer.alpha = true
				}

				renderer.render( scene, camera );
			};

		</script>
	</body>
</html>