<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
		<title>tangle!</title>
	
		<!-- load bootstrap -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
		<!-- load robot mono -->
		<link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
		
		<style>
	
		  html {
			background-color: #ffffff;
		  }
	
		  body {
			background-color: #ffffff;
			font-family: 'Roboto Mono', monospace;
		  }
		</style> 
	</head>
	<body>
		<!-- top title -->
		<div class="container-fluid mt-5">
			<div class="row justify-content-md-center align-items-center">
				<div class="col col-lg-4">
				<!-- space at top! -->
				</div>
				<div class="col col-lg-4 hidden-lg-up" align="center" >
				</div>
			</div>
		</div>
		  
		<div class="container" align="center">
			<p>&nbsp;</p> 
			<h1>tangle!</h1>
			<p>&nbsp;</p> 
	  
			<div class="row justify-content-center mb-3s">
			  <div class="col-sm-12 col-md-8 col-lg-10">
				<p class="">an interactive generative art experiment created by 
				  <a href="https://twitter.com/wookiepandey25" target="_blank">rishi pandey</a>
				</p>
				<p class="">tap/click the canvas to create a noodle at that location
				</p>
				<p class="">tap/click again to stop the noodle
				</p>
				<p class="">repeat this process to tangle your noodles and create your own generative art - unique to only you
				</p>
				<p class="">tap/click <i>save</i> to download/share your art! <a href="https://twitter.com/search?q=tangleart&src=typed_query&f=live" target="_blank">#tangleart</a>
				</p>
			  </div>
			</div>
			<p>&nbsp;</p> 
	  
	  
			<div class="row justify-content-center mb-3">
			  <div class="col-sm-12 col-md-8 col-lg-8">

				<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.js"></script>
				<script src="THREE.MeshLine.js"></script>
				<script src="https://cdn.jsdelivr.net/npm/tweakpane@3.0.7/dist/tweakpane.min.js"></script>
				<script type="module">
		
					import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/OrbitControls.js';
					import { ImprovedNoise } from 'https://cdn.skypack.dev/three@0.133.1/examples/jsm/math/ImprovedNoise.js';
		
					var renderer, camera, scene;//gl renderer, camera and the scene
					// var mesh, line; //mesh and line
					var rotation = 0; //initial rotation
					var strokePoints = [];
					var strokeMeshes = [];
					var points = [getSpawnPoint()];

					//
					// var points = [new THREE.Vector3(0,0,0)]; //create a list of points for the line
					var controls; 
					var seed = Math.random()
					var count = 0;
					var renderLine = false;
					// var numPoints = 10000;
		
					var noiseObject = new ImprovedNoise();
					var PARAMS;

					init();
					animate();
					
					function init() {
						renderer = new THREE.WebGLRenderer(); //render using webgl
						// renderer.setClearColorHex( "rgb(255, 255, 255)", 1 );
						let aspectRatio = 2/3;
						let canvasHeight = 700;
						let canvasWidth = canvasHeight*aspectRatio;
		
						//enforce conditions for mobile friendly canvas
						if (window.innerWidth < canvasWidth) {
							//make canvas mobile friendly
							canvasWidth = 0.8*window.innerWidth;
							canvasHeight = canvasWidth * (1/aspectRatio);
						}
						
						renderer.setSize( canvasWidth, canvasHeight ); //set the render size
						document.getElementById('sketch').appendChild( renderer.domElement ); //parent to sketch id 	
						
						camera = new THREE.PerspectiveCamera( 45, canvasWidth / canvasHeight, 1, 10000 ); // create a camera with (fov, aspect ratio, near, far)
						
						controls = new OrbitControls( camera, renderer.domElement );
						controls.minDistance = 4000;
						controls.maxDistance = 5000;
		
						camera.position.set( 0, 0, 100 ); //set the camera location
						camera.lookAt( 0, 0, 0 ); //set camera lookat 
						controls.update();
		
						scene = new THREE.Scene(); //create a scene : stores items (geometry/lights/etc.)
									
						// line = new MeshLine(); //create the line
						// line.setPoints(points) // set the line to be the points
		
						// var material = new MeshLineMaterial({color: new THREE.Color("rgb(255, 0, 0)"), lineWidth: 10}); //create a material for the line 
						// mesh = new THREE.Mesh(line,material); //set the mesh to be the meshline and material
						// scene.add(mesh); //add the mesh to the scene
						setupUI()
						newStroke()

										
					}
		
					function getRandomNumber(min, max) {
						return Math.random() * (max - min) + min;
					}

					function getSpawnPoint() {
						//return vec3 
						return new THREE.Vector3(getRandomNumber(-1000,1000),getRandomNumber(-1000,1000),getRandomNumber(-1000,1000));
					}

					function setupUI() {
						PARAMS = {
							thickness: 25,
							line: '#ffffff',
							background: '#000000',
							rotate: true
						};
						
						const pane = new Tweakpane.Pane({
										container: document.getElementById('UI'),
										title: 'controls',
										expanded: true,
										});
						
						const canvasControls = pane.addFolder({
									title: 'canvas',
									expanded: true,   // optional
									});
						const strokeControls = pane.addFolder({
												title: 'stroke',
												expanded: true,   // optional
												});
						const newLineBtn = canvasControls.addButton({
										title: 'generate'
										});
						const delPrevBtn = canvasControls.addButton({
										title: 'delete'
										});
						const clearBtn = canvasControls.addButton({
										title: 'clear'
										});
						canvasControls.addInput(PARAMS, 'rotate');
						canvasControls.addInput(PARAMS, 'background');
						strokeControls.addInput(PARAMS, 'thickness',{
										min: 1,
										max: 50
										}
									);
						strokeControls.addInput(PARAMS, 'line');
						const startBtn = strokeControls.addButton({
										title: 'start'
										});
						const stopBtn = strokeControls.addButton({
										title: 'stop'
										});

						//handle buttons
						clearBtn.on('click', () => {
							strokePoints = [];
							strokeMeshes = [];
							newStroke()
							renderLine = false;
						});
						
						newLineBtn.on('click', () => {
							renderLine = true;
							newStroke();
						});

						delPrevBtn.on('click', () => {
							renderLine = false;
							strokePoints.pop();
							strokeMeshes.pop();
						});

						startBtn.on('click', () => {
							renderLine = true;
						});

						stopBtn.on('click', () => {
							renderLine = false;
						});
					}

					function newStroke() {
						//stroke has a set of points
						let points = [getSpawnPoint()];
						//material and line and mesh
						let stroke  = new MeshLine(); //create the line
						stroke.setPoints(points) // set the line to be the points
		
						let material = new MeshLineMaterial({color: new THREE.Color(PARAMS.line) , lineWidth: PARAMS.thickness}); //create a material for the line 
						let mesh = new THREE.Mesh(stroke,material); //set the mesh to be the meshline and material					
						strokePoints.push(points);
						strokeMeshes.push(mesh);
					}

					//animate function onUpdate
					function animate() {
						requestAnimationFrame( animate ); //animate function
						controls.minDistance = 1000;
						renderer.setClearColor (PARAMS.background, 1); //set the bg color
						if (renderLine) {
							// scene.remove(mesh);
							let frame = renderer.info.render.frame;
							let xNoise = noiseObject.noise(frame*0.01,seed,seed);
							let yNoise = noiseObject.noise(frame*0.02,seed,seed);
							let zNoise = noiseObject.noise(frame*0.03,seed,seed);
							
							let xOffset = xNoise * 10;
							let yOffset = yNoise * 10;
							let zOffset = zNoise * 10;
							//get current x y z values, and add noise to them to update]
							let points = strokePoints[strokePoints.length-1];
							let previousPoint = points[points.length-1];
							let x = previousPoint.x + xOffset;
							let y = previousPoint.y + yOffset;
							let z = previousPoint.z + zOffset;
							strokePoints[strokePoints.length-1].push(new THREE.Vector3(x,y,z));
							count += 1
						}
						let stroke  = new MeshLine();
						stroke.setPoints(strokePoints[strokePoints.length-1])
						strokeMeshes[strokeMeshes.length-1].geometry = stroke
						// mesh.geometry = line;
						// console.log(PARAMS.color)
						strokeMeshes[strokeMeshes.length-1].material.lineWidth = PARAMS.thickness
						strokeMeshes[strokeMeshes.length-1].material.color = new THREE.Color(PARAMS.line)
						scene.add(strokeMeshes[strokeMeshes.length-1])
						//rotate line
						if (PARAMS.rotate) {
							rotation -= 0.002
							strokeMeshes[strokeMeshes.length-1].rotation.y = rotation;
						}
						renderer.render( scene, camera );
					}
				</script>
				<div id="UI"></div>
				<p>&nbsp;</p> 
				<div id="sketch"></div>
			  </div>
			</div> 
			<p>&nbsp;</p> 
	
	  
		</div>
		  
	</body>
</html>
