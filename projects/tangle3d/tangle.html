<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.3/p5.min.js"></script> -->
		<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.7.3/addons/p5.dom.min.js"></script> -->
		<!-- <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> -->
		<title>tangle!</title>
	
		<!-- load bootstrap -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
		<!-- load robot mono -->
		<link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
		
		<style>
	
		  html {
			background-color: #ffffff;
		  }
	
		  body {
			background-color: #ffffff;
			font-family: 'Roboto Mono', monospace;
		  }
		</style> 
	</head>
	<body>
		<!-- top title -->
		<div class="container-fluid mt-5">
			<div class="row justify-content-md-center align-items-center">
				<div class="col col-lg-4">
				<!-- space at top! -->
				</div>
				<div class="col col-lg-4 hidden-lg-up" align="center" >
				</div>
			</div>
		</div>
		  
		<div class="container" align="center">
			<p>&nbsp;</p> 
			<h1>tangle!</h1>
			<p>&nbsp;</p> 
	  
			<div class="row justify-content-center mb-3s">
			  <div class="col-sm-12 col-md-8 col-lg-10">
				<p class="">an interactive generative art experiment created by 
				  <a href="https://twitter.com/wookiepandey25" target="_blank">rishi pandey</a>
				</p>
				<p class="">tap/click the canvas to create a noodle at that location
				</p>
				<p class="">tap/click again to stop the noodle
				</p>
				<p class="">repeat this process to tangle your noodles and create your own generative art - unique to only you
				</p>
				<p class="">tap/click <i>save</i> to download/share your art! <a href="https://twitter.com/search?q=tangleart&src=typed_query&f=live" target="_blank">#tangleart</a>
				</p>
			  </div>
			</div>
			<p>&nbsp;</p> 
	  
	  
			<div class="row justify-content-center mb-3">
			  <div class="col-sm-12 col-md-8 col-lg-8">
				<div id="sketch"></div>
				<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.js"></script>
				<script src="THREE.MeshLine.js"></script>
				<script src="https://cdn.jsdelivr.net/npm/tweakpane@3.0.7/dist/tweakpane.min.js"></script>
				<script type="module">
		
					import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/OrbitControls.js';
					import { ImprovedNoise } from 'https://cdn.skypack.dev/three@0.133.1/examples/jsm/math/ImprovedNoise.js';
					// import { useControls } from 'leva'
		
					var renderer, camera, scene;//gl renderer, camera and the scene
					var mesh, line; //mesh and line
					var rotation = 0; //initial rotation
					var points = [new THREE.Vector3(0,0,0)]; //create a list of points for the line
		
					var seed = Math.random()
					var count = 0;
					var numPoints = 10000;
		
					var noiseObject = new ImprovedNoise();
		
					init();
					animate();
		
					function init() {
						renderer = new THREE.WebGLRenderer(); //render using webgl
						// renderer.setClearColorHex( "rgb(255, 255, 255)", 1 );
						let aspectRatio = 2/3;
						let canvasHeight = 700;
						let canvasWidth = canvasHeight*aspectRatio;
		
						//enforce conditions for mobile friendly canvas
						if (window.innerWidth < canvasWidth) {
							//make canvas mobile friendly
							canvasWidth = 0.8*window.innerWidth;
							canvasHeight = canvasWidth * (1/aspectRatio);
						}
						
						renderer.setSize( canvasWidth, canvasHeight ); //set the render size
						document.getElementById('sketch').appendChild( renderer.domElement );
						// document.body.appendChild( renderer.domElement ); //adds a canvas element to html so that we can view the rendered scene
						
						camera = new THREE.PerspectiveCamera( 45, canvasWidth / canvasHeight, 1, 10000 ); // create a camera with (fov, aspect ratio, near, far)
						
						const controls = new OrbitControls( camera, renderer.domElement );
						controls.minDistance = 100;
						controls.maxDistance = 5000;
		
						camera.position.set( 0, 0, 100 ); //set the camera location
						camera.lookAt( 0, 0, 0 ); //set camera lookat 
						controls.update();
		
						scene = new THREE.Scene(); //create a scene : stores items (geometry/lights/etc.)
									
		
						line = new MeshLine(); //create the line
						line.setPoints(points) // set the line to be the points
		
						var material = new MeshLineMaterial({color: new THREE.Color("rgb(255, 0, 0)"), lineWidth: 10}); //create a material for the line 
						mesh = new THREE.Mesh(line,material); //set the mesh to be the meshline and material
						scene.add(mesh); //add the mesh to the scene
		
		
						const PARAMS = {
						factor: 123,
						title: 'hello',
						color: '#0f0',
						};
		
						const pane = new Tweakpane.Pane();
						
						pane.addInput(PARAMS, 'factor');
						pane.addInput(PARAMS, 'title');
						pane.addInput(PARAMS, 'color');
		
					}
		
					function getRandomNumber(min, max) {
						return Math.random() * (max - min) + min;
					}
		
					//animate function onUpdate
					function animate() {
						requestAnimationFrame( animate ); //animate function
						if (count < numPoints) {
							scene.remove(mesh);
							let frame = renderer.info.render.frame;
							let xNoise = noiseObject.noise(frame*0.01,seed,seed);
							let yNoise = noiseObject.noise(frame*0.02,seed,seed);
							let zNoise = noiseObject.noise(frame*0.03,seed,seed);
							
							let xOffset = xNoise * 5;
							let yOffset = yNoise * 5;
							let zOffset = zNoise * 5;
							//get current x y z values, and add noise to them to update
							let previousPoint = points[points.length-1];
							let x = previousPoint.x + xOffset;
							let y = previousPoint.y + yOffset;
							let z = previousPoint.z + zOffset;
							points.push(new THREE.Vector3(x,y,z));
		
							line.setPoints(points)
							mesh.geometry = line;
							scene.add(mesh)
							count += 1
						}
						//rotate line
						rotation += 0.001
						// mesh.rotation.y = rotation;
						renderer.render( scene, camera );
					}
				</script>
			  </div>
			</div> 
			<p>&nbsp;</p> 
		
			<div class="row justify-content-center mb-3s">
			  <div class="col-sm-12 col-md-8 col-lg-10">
				<p class="">tap/click <i>reset</i> to clear the canvas and generate a new color palette
				</p>
				<p>&nbsp;</p> 
			  </div>
			</div>
	  
		</div>
		
		<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.js"></script>
		<script src="THREE.MeshLine.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/tweakpane@3.0.7/dist/tweakpane.min.js"></script>
		<script type="module">

			import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/OrbitControls.js';
			import { ImprovedNoise } from 'https://cdn.skypack.dev/three@0.133.1/examples/jsm/math/ImprovedNoise.js';
			// import { useControls } from 'leva'

			var renderer, camera, scene;//gl renderer, camera and the scene
			var mesh, line; //mesh and line
			var rotation = 0; //initial rotation
			var points = [new THREE.Vector3(0,0,0)]; //create a list of points for the line

			var seed = Math.random()
			var count = 0;
			var numPoints = 10000;

			var noiseObject = new ImprovedNoise();

			init();
			animate();

			function init() {
				renderer = new THREE.WebGLRenderer(); //render using webgl
				// renderer.setClearColorHex( "rgb(255, 255, 255)", 1 );
				let aspectRatio = 2/3;
				let canvasHeight = 700;
				let canvasWidth = canvasHeight*aspectRatio;

				//enforce conditions for mobile friendly canvas
				if (window.innerWidth < canvasWidth) {
					//make canvas mobile friendly
					canvasWidth = 0.8*window.innerWidth;
					canvasHeight = canvasWidth * (1/aspectRatio);
				}
				
				renderer.setSize( canvasWidth, canvasHeight ); //set the render size
				document.body.appendChild( renderer.domElement ); //adds a canvas element to html so that we can view the rendered scene
				
				camera = new THREE.PerspectiveCamera( 45, canvasWidth / canvasHeight, 1, 10000 ); // create a camera with (fov, aspect ratio, near, far)
				
				const controls = new OrbitControls( camera, renderer.domElement );
				controls.minDistance = 100;
				controls.maxDistance = 5000;

				camera.position.set( 0, 0, 100 ); //set the camera location
				camera.lookAt( 0, 0, 0 ); //set camera lookat 
				controls.update();

				scene = new THREE.Scene(); //create a scene : stores items (geometry/lights/etc.)
							

				line = new MeshLine(); //create the line
				line.setPoints(points) // set the line to be the points

				var material = new MeshLineMaterial({color: new THREE.Color("rgb(255, 0, 0)"), lineWidth: 10}); //create a material for the line 
				mesh = new THREE.Mesh(line,material); //set the mesh to be the meshline and material
				scene.add(mesh); //add the mesh to the scene


				const PARAMS = {
				factor: 123,
				title: 'hello',
				color: '#0f0',
				};

				const pane = new Tweakpane.Pane();
				
				pane.addInput(PARAMS, 'factor');
				pane.addInput(PARAMS, 'title');
				pane.addInput(PARAMS, 'color');

			}

			function getRandomNumber(min, max) {
				return Math.random() * (max - min) + min;
			}

			//animate function onUpdate
			function animate() {
				requestAnimationFrame( animate ); //animate function
				if (count < numPoints) {
					scene.remove(mesh);
					let frame = renderer.info.render.frame;
					let xNoise = noiseObject.noise(frame*0.01,seed,seed);
					let yNoise = noiseObject.noise(frame*0.02,seed,seed);
					let zNoise = noiseObject.noise(frame*0.03,seed,seed);
					
					let xOffset = xNoise * 5;
					let yOffset = yNoise * 5;
					let zOffset = zNoise * 5;
					//get current x y z values, and add noise to them to update
					let previousPoint = points[points.length-1];
					let x = previousPoint.x + xOffset;
					let y = previousPoint.y + yOffset;
					let z = previousPoint.z + zOffset;
					points.push(new THREE.Vector3(x,y,z));

					line.setPoints(points)
					mesh.geometry = line;
					scene.add(mesh)
					count += 1
				}
				//rotate line
				rotation += 0.001
				// mesh.rotation.y = rotation;
				renderer.render( scene, camera );
			}
		</script> -->
		  
	</body>
</html>
