<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
		<title>tangle!</title>
	
		<!-- load bootstrap -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
		<!-- load robot mono -->
		<link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
		
		<style>
	
		  html {
			background-color: #ffffff;
		  }
	
		  body {
			background-color: #ffffff;
			font-family: 'Roboto Mono', monospace;
		  }
		</style> 
	</head>
	<body>
		<!-- top title -->
		<div class="container-fluid mt-5">
			<div class="row justify-content-md-center align-items-center">
				<div class="col col-lg-4">
				<!-- space at top! -->
				</div>
				<div class="col col-lg-4 hidden-lg-up" align="center" >
				</div>
			</div>
		</div>
		  
		<div class="container" align="center">
			<p>&nbsp;</p> 
			<h1>tangle!</h1>
			<p>&nbsp;</p> 
	  
			<div class="row justify-content-center mb-3s">
			  <div class="col-sm-12 col-md-8 col-lg-10">
				<p class="">an interactive generative art experiment created by 
				  <a href="https://twitter.com/wookiepandey25" target="_blank">rishi pandey</a>
				</p>
				<p class="">tap/click the canvas to create a noodle at that location
				</p>
				<p class="">tap/click again to stop the noodle
				</p>
				<p class="">repeat this process to tangle your noodles and create your own generative art - unique to only you
				</p>
				<p class="">tap/click <i>save</i> to download/share your art! <a href="https://twitter.com/search?q=tangleart&src=typed_query&f=live" target="_blank">#tangleart</a>
				</p>
			  </div>
			</div>
			<p>&nbsp;</p> 
	  
	  
			<div class="row justify-content-center mb-3">
			  <div class="col-sm-12 col-md-8 col-lg-8">

				<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.js"></script>
				<script src="THREE.MeshLine.js"></script>
				<script src="https://cdn.jsdelivr.net/npm/tweakpane@3.0.7/dist/tweakpane.min.js"></script>
				<script type="module">
		
					import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/OrbitControls.js';
					import { ImprovedNoise } from 'https://cdn.skypack.dev/three@0.133.1/examples/jsm/math/ImprovedNoise.js';
		
					var renderer, camera, scene;//gl renderer, camera and the scene
					var rotation = 0; //initial rotation
					var strokePoints = []; //points for every stroke
					var strokeMeshes = []; //mesh (w/ geo and material) for every stroke

					var controls; //controls variable
					var seed = Math.random() //seed for this piece
					var renderLine = false; 
		
					var noiseObject = new ImprovedNoise(); //improved noise object
					var PARAMS; //params for UI

					init(); //onStart
					animate(); //onUpdate
					
					function init() {
						renderer = new THREE.WebGLRenderer(); //render using webgl
						let aspectRatio = 2/3; //canvas aspect ratio
						let canvasHeight = 700; //height of canvas
						let canvasWidth = canvasHeight*aspectRatio; //width based on AR
		
						//enforce conditions for mobile friendly canvas
						if (window.innerWidth < canvasWidth) {
							//make canvas mobile friendly
							canvasWidth = 0.8*window.innerWidth;
							canvasHeight = canvasWidth * (1/aspectRatio);
						}
						
						renderer.setSize( canvasWidth, canvasHeight ); //set the render size
						document.getElementById('sketch').appendChild( renderer.domElement ); //parent to sketch id 	
						
						camera = new THREE.PerspectiveCamera(80, canvasWidth / canvasHeight, 1, 1000001 ); // create a camera with (fov, aspect ratio, near, far)
						
						controls = new OrbitControls( camera, renderer.domElement ); //setup orbit controls
						controls.minDistance = 7000; //start far out
						controls.maxDistance = 100000; //max distance for orbit controls
						// camera.position.set( - 40, 0, 60 );


						camera.position.set( 0, 0, 100 ); //set the camera location
						camera.lookAt( 0, 0, 0 ); //set camera lookat 
						controls.update();
		
						scene = new THREE.Scene(); //create a scene : stores items (geometry/lights/etc.)
									
						setupUI() //setup the UI
						newStroke() //generate the first stroke		
					}
					
					//random num between bounds
					function getRandomNumber(min, max) {
						return Math.random() * (max - min) + min;
					}	

					//spawn point in box 2000x2000x2000 centered at origin
					function getSpawnPoint() {
						//return vec3 
						return new THREE.Vector3(getRandomNumber(-1000,1000),getRandomNumber(-1000,1000),getRandomNumber(-1000,1000));
					}

					//setup the UI
					function setupUI() {
						//initial params
						PARAMS = {
							thickness: 25,
							line: '#ffffff',
							background: '#000000'
						};
						//creation of pane
						const pane = new Tweakpane.Pane({
										container: document.getElementById('UI'),
										title: 'controls',
										expanded: true,
										});
						//canvas controls section
						const canvasControls = pane.addFolder({
									title: 'canvas',
									expanded: true,   // optional
									});
						//stroke controls section
						const strokeControls = pane.addFolder({
												title: 'stroke',
												expanded: true,   // optional
												});
						//button to generate new stroke
						const newLineBtn = canvasControls.addButton({
										title: 'generate stroke'
										});
						//clear the canvas 
						const clearBtn = canvasControls.addButton({
										title: 'clear'
										});
						//set the bg color of the canvas
						canvasControls.addInput(PARAMS, 'background');
						//thickness controls for stroke
						strokeControls.addInput(PARAMS, 'thickness',{
										min: 1,
										max: 500
										}
									);
						//color controls for stroke
						strokeControls.addInput(PARAMS, 'line');

						//handle buttons
						//clear/reset button
						clearBtn.on('click', () => {
							//remove every mesh
							for (let i = 0; i < strokeMeshes.length; i++) {
								scene.remove(strokeMeshes[i])
							}
							strokePoints = [];
							strokeMeshes = [];
							newStroke()
							renderLine = false;
						});

						//new stroke
						newLineBtn.on('click', () => {
							renderLine = true;
							newStroke();
						});

					}

					//generate a new stroke
					function newStroke() {
						//stroke has a set of points
						let points = [getSpawnPoint()];
						//material and line and mesh
						let stroke  = new MeshLine(); //create the line
						stroke.setPoints(points) // set the line to be the points
						let material = new MeshLineMaterial({color: new THREE.Color(PARAMS.line) , lineWidth: PARAMS.thickness}); //create a material for the line 
						let mesh = new THREE.Mesh(stroke,material); //set the mesh to be the meshline and material					
						strokePoints.push(points); //add to the global array
						strokeMeshes.push(mesh);
						// renderLine = true; //draw the line
					}

					//animate function onUpdate
					function animate() {
						requestAnimationFrame( animate ); //animate function

						controls.minDistance = 1000; //change the min distance sso onUpdate you can go up close
						renderer.setClearColor (PARAMS.background, 1); //set the bg color
						console.log(seed)
						if (renderLine) {
							let frame = renderer.info.render.frame;
							let xNoise = noiseObject.noise(frame*0.01*seed,seed,seed);
							let yNoise = noiseObject.noise(frame*0.02*seed,seed,seed);
							let zNoise = noiseObject.noise(frame*0.03*seed,seed,seed);
							
							let xOffset = xNoise * 200;
							let yOffset = yNoise * 200;
							let zOffset = zNoise * 200;
							//get current x y z values, and add noise to them to update]
							let points = strokePoints[strokePoints.length-1];
							let previousPoint = points[points.length-1];
							let boundary = 10000;
							if (previousPoint.x + xOffset > boundary || previousPoint.x + xOffset < -1 * boundary) {
								xOffset = xOffset * -1;
							}
							if (previousPoint.y + yOffset > boundary || previousPoint.y + yOffset < -1 * boundary) {
								yOffset = yOffset * -1;
							}
							if (previousPoint.z + zOffset > boundary || previousPoint.z + zOffset < -1 * boundary) {
								zOffset = zOffset * -1;
							}
 							let x = previousPoint.x + xOffset;
							let y = previousPoint.y + yOffset;
							let z = previousPoint.z + zOffset;
							strokePoints[strokePoints.length-1].push(new THREE.Vector3(x,y,z));
						}
						let stroke  = new MeshLine();
						stroke.setPoints(strokePoints[strokePoints.length-1])
						strokeMeshes[strokeMeshes.length-1].geometry = stroke
						strokeMeshes[strokeMeshes.length-1].material.lineWidth = PARAMS.thickness
						strokeMeshes[strokeMeshes.length-1].material.color = new THREE.Color(PARAMS.line)
						scene.add(strokeMeshes[strokeMeshes.length-1])
						renderer.render( scene, camera );
					}
				</script>
				<div id="UI"></div>
				<p>&nbsp;</p> 
				<div id="sketch"></div>
			  </div>
			</div> 
			<p>&nbsp;</p> 
	
	  
		</div>
		  
	</body>
</html>
