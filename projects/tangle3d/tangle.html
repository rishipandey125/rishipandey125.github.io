<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
		<title>tangle!</title>
	
		<!-- load bootstrap -->
		<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
		<!-- load robot mono -->
		<link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
		
		<style>
	
		  html {
			background-color: #ffffff;
		  }
	
		  body {
			background-color: #ffffff;
			font-family: 'Roboto Mono', monospace;
		  }
		</style> 
		<!-- style for tweakpane -->
		<style> 
			:root {
			  --tp-base-background-color: hsla(230, 5%, 90%, 1.00);
			  --tp-base-shadow-color: hsla(0, 0%, 0%, 0.10);
			  --tp-button-background-color: hsla(230, 7%, 75%, 1.00);
			  --tp-button-background-color-active: hsla(230, 7%, 60%, 1.00);
			  --tp-button-background-color-focus: hsla(230, 7%, 65%, 1.00);
			  --tp-button-background-color-hover: hsla(230, 7%, 70%, 1.00);
			  --tp-button-foreground-color: hsla(230, 10%, 30%, 1.00);
			  --tp-container-background-color: hsla(230, 15%, 30%, 0.20);
			  --tp-container-background-color-active: hsla(230, 15%, 30%, 0.32);
			  --tp-container-background-color-focus: hsla(230, 15%, 30%, 0.28);
			  --tp-container-background-color-hover: hsla(230, 15%, 30%, 0.24);
			  --tp-container-foreground-color: hsla(230, 10%, 30%, 1.00);
			  --tp-groove-foreground-color: hsla(230, 15%, 30%, 0.10);
			  --tp-input-background-color: hsla(230, 15%, 30%, 0.10);
			  --tp-input-background-color-active: hsla(230, 15%, 30%, 0.22);
			  --tp-input-background-color-focus: hsla(230, 15%, 30%, 0.18);
			  --tp-input-background-color-hover: hsla(230, 15%, 30%, 0.14);
			  --tp-input-foreground-color: hsla(230, 10%, 30%, 1.00);
			  --tp-label-foreground-color: hsla(230, 10%, 30%, 0.70);
			  --tp-monitor-background-color: hsla(230, 15%, 30%, 0.10);
			  --tp-monitor-foreground-color: hsla(230, 10%, 30%, 0.50);
			}
			</style>
	</head>
	<body>
		<canvas id="canvas"></canvas><br/><br/>

		<!-- top title -->
		<div class="container-fluid mt-5">
			<div class="row justify-content-md-center align-items-center">
				<div class="col col-lg-4">
				<!-- space at top! -->
				</div>
				<div class="col col-lg-4 hidden-lg-up" align="center" >
				</div>
			</div>
		</div>
		  
		<div class="container" align="center">
			<p>&nbsp;</p> 
			<h1>tangle!</h1>
			<p>&nbsp;</p> 
	  
			<div class="row justify-content-center mb-3s">
			  <div class="col-sm-12 col-md-8 col-lg-6">
				<p class="">an interactive generative art experiment created by 
				  <a href="https://twitter.com/wookiepandey25" target="_blank">rishi pandey</a>
				</p>
				<p class="">tap/click the canvas to create a noodle at that location
				</p>
				<p class="">tap/click again to stop the noodle
				</p>
				<p class="">repeat this process to tangle your noodles and create your own generative art - unique to only you
				</p>
				<p class="">tap/click <i>save</i> to download/share your art! <a href="https://twitter.com/search?q=tangleart&src=typed_query&f=live" target="_blank">#tangleart</a>
				</p>
			  </div>
			</div>

			<p>&nbsp;</p> 
	  
	  
			<div class="row justify-content-center mb-3">
				<div class="col-9 col-md-5 col-lg-3">
				<!-- <div class="col-sm-5 col-md-4 col-lg-3"> -->
				<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.js"></script>
				<script src="THREE.MeshLine.js"></script>
				<!-- <script src="gif.js"></script> -->
				<script src="https://cdn.jsdelivr.net/npm/tweakpane@3.0.7/dist/tweakpane.min.js"></script>
				<script type="module">
					
					// Import OrbitControls for Dragging Viewport and Improved Noise for Perlin Noise
					import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/OrbitControls.js';
					import { ImprovedNoise } from 'https://cdn.skypack.dev/three@0.133.1/examples/jsm/math/ImprovedNoise.js';
		
					var renderer, camera, scene; //gl renderer, camera and the scene
					var rotation = 0; //initial rotation
					var strokePoints = []; //points for every stroke
					var strokeMeshes = []; //mesh (w/ geo and material) for every stroke
					const canvas = document.getElementById( 'canvas' );

					var controls; //controls variable
					var seed;
					var renderLine = false; 
					var noiseObject = new ImprovedNoise(); //improved noise object
					var PARAMS; //params for UI
					const MIN_THICKNESS = 25;
					const MAX_THICKNESS = 300;
					init(); //onStart
					animate(); //onUpdate
					
					function init() {
						renderer = new THREE.WebGLRenderer({canvas: canvas, antialias: true}); //render using webgl
						let aspectRatio = 2/3; //canvas aspect ratio
						let canvasHeight = 700; //height of canvas
						let canvasWidth = canvasHeight*aspectRatio; //width based on aspect ratio
						
						//enforce conditions for mobile friendly canvas
						if (window.innerWidth < canvasWidth) {
							//make canvas mobile friendly
							canvasWidth = 0.8*window.innerWidth;
							canvasHeight = canvasWidth * (1/aspectRatio);
						}
						
						renderer.setSize( canvasWidth, canvasHeight ); //set the render size
						document.getElementById('sketch').appendChild( renderer.domElement ); //parent to sketch id 	
						
						camera = new THREE.PerspectiveCamera(80, canvasWidth / canvasHeight, 1, 26000 ); // create a camera with (fov, aspect ratio, near, far)
						
						controls = new OrbitControls( camera, renderer.domElement ); //setup orbit controls
						controls.minDistance = 11000; //start far out
						controls.maxDistance = 13000; //max distance for orbit controls
						camera.position.set( 0, 0, 100 ); //set the camera location
						camera.lookAt( 0, 0, 0 ); //set camera lookat 

						controls.update();
		
						scene = new THREE.Scene(); //create a scene : stores items (geometry/lights/etc.)
									
						setupUI() //setup the UI
						newStroke() //generate the first stroke		
					}
					
	

					//random num between bounds
					function getRandomNumber(min, max) {
						return Math.random() * (max - min) + min;
					}	
					
					//setup the UI
					function setupUI() {
						//initial params
						PARAMS = {
							line: '#ffffff',
							thickness: 25,
							background: '#000000'
						};

						const pane = new Tweakpane.Pane({
											container: document.getElementById('UI'),
											expanded: true
										});
						const savePane = new Tweakpane.Pane({
							container: document.getElementById('UI_SAVE'),
							expanded: true
						});

						const tab = pane.addTab({pages: [
														{title: 'canvas'},
														{title: 'noodle'},
													],
												});
						
						//button to generate new stroke
						const newLineBtn = tab.pages[0].addButton({
										title: 'generate noodle'
										});
						tab.pages[0].addSeparator();


						//set the bg color of the canvas
						tab.pages[0].addInput(PARAMS, 'background',{
												label: 'color',
												picker: 'inline',
												expanded: true,
												});
				

						const saveBtn = savePane.addButton({
							title: 'save'
						});
						tab.pages[0].addSeparator();

						//thickness controls for stroke
						tab.pages[1].addInput(PARAMS, 'thickness',{
										label: 'thickness',
										min: 1,
										max: 100,
										step: 1
										}
									);

						tab.pages[1].addSeparator();

						//color controls for stroke
						tab.pages[1].addInput(PARAMS, 'line',{
												label: 'color',
												picker: 'inline',
												expanded: true,
												});

		
						//new stroke
						newLineBtn.on('click', () => {
							renderLine = true;
							newStroke();
						});


						saveBtn.on('click', () => {
							// start rotation
							// recording length * num frames (60?) = num frames in recording
							//interval for rotation = 1/num frames in recording
							renderLine = false // stop rendering the line
							startRecording()

							console.log("Working!")
						});

					}

					function startRecording() {
						const chunks = []; // here we will store our recorded media chunks (Blobs)
						const stream = canvas.captureStream(); // grab our canvas MediaStream
						var options;
						var rec;
						try {
							options = {
								mimeType: 'video/webm',
								videoBitsPerSecond : 3000000
							};
							rec = new MediaRecorder(stream, options);
							// every time the recorder has new data, we will store it in our array
							rec.ondataavailable = e => chunks.push(e.data);
							// only when the recorder stops, we construct a complete Blob from all the chunks
							rec.onstop = e => exportVid(new Blob(chunks, {type: 'vid/webm'}),'.webm');
						}
						catch (err1) {
							try {
								options = {
									mimeType: 'video/mp4',
									videoBitsPerSecond : 3000000
								};
								// Fallback for iOS
								rec = new MediaRecorder(stream, options);
								// every time the recorder has new data, we will store it in our array
								rec.ondataavailable = e => chunks.push(e.data);
								// only when the recorder stops, we construct a complete Blob from all the chunks
								rec.onstop = e => exportVid(new Blob(chunks, {type: 'vid/mp4'}),'.mp4');
							}
							catch (err2) {
								// If fallback doesn't work either. Log / process errors.
								console.error({err1});
								console.error({err2})
							}
						}
						
						rec.start();
						setTimeout(()=>rec.stop(), 11000); // stop recording in 11s
					}

					function exportVid(blob,extension) {
						const link = document.createElement( 'a' );
						link.href = URL.createObjectURL( blob );
						link.download = 'tangle' + extension;
						link.dispatchEvent( new MouseEvent( 'click' ) );
					}
					
					//generate a new stroke
					function newStroke() {
						//stroke has a set of points
						let points = [];
						//material and line and mesh
						let stroke  = new MeshLine(); //create the line
						stroke.setPoints(points) // set the line to be the points
						let material = new MeshLineMaterial({color: new THREE.Color(PARAMS.line) , side: THREE.DoubleSide,lineWidth: lerp(MIN_THICKNESS,MAX_THICKNESS,PARAMS.thickness/100)}); //create a material for the line 
						let mesh = new THREE.Mesh(stroke,material); //set the mesh to be the meshline and material					
						strokePoints.push(points); //add to the global array
						strokeMeshes.push(mesh);
						seed = getRandomNumber(0.3,0.8);
						scene.add(strokeMeshes[strokeMeshes.length-1])
					}
					
					function lerp(min,max,i) {
						return min + ((max - min) * i);
					}

					//animate function onUpdate
					function animate() {
						requestAnimationFrame( animate ); //animate function
						controls.minDistance = 1000; //change the min distance so onUpdate you can go up close
						renderer.setClearColor (PARAMS.background, 1); //set the bg color
						if (renderLine) {
							let frame = renderer.info.render.frame;
							let points = strokePoints[strokePoints.length-1];
							// let previousPoint  = points[points.length-1];
							let boundary = 7000;
							let xNoise = noiseObject.noise(frame*0.003,seed,seed);
							let yNoise = noiseObject.noise(frame*0.006,seed,seed);
							let zNoise = noiseObject.noise(frame*0.008,seed,seed);
							let xOffset = xNoise * boundary;
							let yOffset = yNoise * boundary;
							let zOffset = zNoise * boundary;
							let nextPoint = new THREE.Vector3(xOffset,yOffset,zOffset);
							strokePoints[strokePoints.length-1].push(nextPoint);
							let stroke = strokeMeshes[strokeMeshes.length-1].geometry;
							stroke.setPoints(strokePoints[strokePoints.length-1])
							strokeMeshes[strokeMeshes.length-1].material.lineWidth = lerp(MIN_THICKNESS,MAX_THICKNESS,PARAMS.thickness/100)
							strokeMeshes[strokeMeshes.length-1].material.color = new THREE.Color(PARAMS.line);
						}
						rotation += 0.00166666666;
						// //set every meshes rotation
						for (let i = 0; i < strokeMeshes.length; i++) {
							strokeMeshes[i].rotation.y = rotation;
						}
						renderer.render( scene, camera );
					}
				</script>
				<div id="UI"></div>
				<p>&nbsp;</p> 
			  </div>
			</div> 

			<div class="row justify-content-center mb-3">
				<div class="col-sm-12 col-md-8 col-lg-10">

					<div id="sketch"></div>
				</div>
			</div> 

			<div class="row justify-content-center mb-3">
				<div class="col-3 col-md-2 col-lg-1">
					<div id="UI_SAVE"></div>
					<p>&nbsp;</p> 

				</div>
			</div> 
	  
		</div>
		  
	</body>
</html>