<!DOCTYPE HTML> 
<html> 
	<head> 
		<meta charset="utf-8"> 
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<title>generative pathtraced</title> 
		
		<style> 
			html, body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
				width: 100%;
				height: 100%;
			}
			/* canvas {
				width: 100%;
				height: 100%;
			} */
		</style> 
	</head> 
	<body> 
		<canvas  id="myCanvas" width =800 height=800> </canvas>

		<!-- <canvas></canvas> -->
		<div id="info"></div> 
 
		<script id="vs" type="x-shader/vertex"> 
			attribute vec3 position;
 
			void main() {
 
				gl_Position = vec4( position, 1.0 );
 
			}
 
		</script> 
 
		<script id="fs" type="x-shader/fragment"> 
			precision highp float;

			uniform float time;
			uniform vec2 resolution; //vec2(screen_width,screen_height)

		
			//random functions using gold noise 
			float seed = 0.0;

			float random (vec2 st) {
				return fract(sin(dot(st.xy,
									 vec2(12.9898,78.233)))*
					43758.5453123);
			}

			vec2 random2(float seed) {
				return vec2(
				  random(vec2(seed-1.23, (seed+3.1)* 3.2)),
				  random(vec2(seed+12.678, seed - 5.8324))
				  );
			}
			  
			vec3 random3(float seed){
				return vec3(
					random(vec2(seed-0.678, seed-0.123)),
					random(vec2(seed-0.3, seed+0.56)),
					random(vec2(seed+0.1234, seed-0.523))
					);
			}


			vec3 random_in_unit_sphere(float seed) {
				vec3 h = random3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);
				float phi = h.y;
				float r = pow(h.z, 1./3.);
				return r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);
			}
			 
 			struct ray {
				vec3 origin;
				vec3 direction;
			};

			struct camera {
				vec3 origin, lower_left_corner, horizontal, vertical; 
				float focal_length;
			};

			struct hit_record { 
				vec3 point;
				vec3 normal;
				float t;
			};
			
			struct hittable { // this is just a sphere right now 
				vec3 center; 
				float radius; 
			};

			ray get_camera_ray(camera c, vec2 uv) {
				return ray(c.origin,c.lower_left_corner + (uv.x*c.horizontal) + (uv.y*c.vertical) - c.origin);
			}

			vec3 get_point_on_ray(ray r, float t) {
				return r.origin + (t*r.direction);
			}
			
			bool hittable_hit (hittable h, ray r, float t_min, float t_max, inout hit_record rec) {
				vec3 oc = r.origin - h.center;
				float a = dot(r.direction,r.direction);
				float half_b = dot(oc,r.direction);
				float c = dot(oc,oc) - h.radius*h.radius;
				float discriminant = (half_b*half_b) - (a*c);
				if (discriminant < 0.0) {
					return false;
				}
				float root =  (-half_b - sqrt(discriminant))/a;
				//determine which root is in bounds
				if (root < t_min || t_max < root) {
					root = ((-half_b) + sqrt(discriminant))/a;
					if (root < t_min || t_max < root) {
						return false;
					}
				}
				rec.t = root; 
				rec.point = get_point_on_ray(r,root);
				rec.normal = (rec.point - h.center)/h.radius;
				return true;
			}

			bool world_hit(ray r, float t_min, float t_max, out hit_record rec) {
				rec.t = t_max;
				hittable ground = hittable(vec3(0.0,-100.5,-1.0),100.0);
				hittable ball = hittable(vec3(0.0,0.0,-1.0),0.5);
				
				bool hit = false;
				hit = hittable_hit(ground,r,t_min,rec.t,rec) || hit;
				hit = hittable_hit(ball,r,t_min,rec.t,rec) || hit;
				return hit;
			}


			vec3 bg_color(ray r) {
				vec3 unit_direction = normalize(r.direction);
				float t = 0.5 * (unit_direction.y + 1.0);
				vec3 light_blue = vec3(0.5,0.7,1.0);
				vec3 white = vec3(1.0);
				vec3 bg = mix(white,light_blue,t);
				return bg;
			}

			vec3 color(ray r) {
				hit_record rec;

				vec3 color = vec3(1.0);


				//50 is max recursion right now
				for (int i = 0; i < 50; i++) {
					bool hit = world_hit(r,0.001,1e5,rec);
					if (hit) {
						vec3 rd = normalize(rec.normal + random_in_unit_sphere(seed));
						color *= 0.5;
						r.origin = rec.point;
						r.direction = rd;
					} else {
						color *= bg_color(r);
						return color;
					}
				}
				
				return color;
			}

			void main( void ) {
				//image
				float aspect_ratio = resolution.x/resolution.y;
				//camera
				float viewport_height = 2.0;
				float viewport_width = viewport_height * aspect_ratio;

				camera c;
				c.focal_length = 1.0;
				c.origin = vec3(0.0);
				// how far we should traverse the viewport horizontally and vertically to cast rays

				c.horizontal = vec3(viewport_width,0.0,0.0);
				c.vertical = vec3(0.0,viewport_height,0.0);

				//viewport lower left corner in 3d space
				c.lower_left_corner = c.origin - (c.horizontal/2.0) - (c.vertical/2.0) - vec3(0.0,0.0,c.focal_length);

				vec2 uv = gl_FragCoord.xy / resolution.xy; //calc quad uv (0-1) down to up and left to right
				//seed 
				seed = random(uv.xy * mod(time,100.0));
				
				vec3 pixel_color = vec3(0.0);
				for (int i = 0; i < 10; i++) { //anti-aliasing
					ray r = get_camera_ray(c,uv+random2(seed)*0.001);
					pixel_color += color(r);
				}
				float scale = 1.0/10.0; //1/# of samples
				//gamma correction
				pixel_color.r = sqrt(scale*pixel_color.r);
				pixel_color.g = sqrt(scale*pixel_color.g);
				pixel_color.b = sqrt(scale*pixel_color.b);
				gl_FragColor = vec4(pixel_color,1.0);
			}
			
		</script> 
 
		<script> 
 
			/**
			 * Provides requestAnimationFrame in a cross browser way.
			 * paulirish.com/2011/requestanimationframe-for-smart-animating/
			 */
			window.requestAnimationFrame = window.requestAnimationFrame || ( function() {

				return  window.webkitRequestAnimationFrame ||
				        window.mozRequestAnimationFrame ||
				        window.oRequestAnimationFrame ||
				        window.msRequestAnimationFrame ||
				        function(  callback, element ) {
					        window.setTimeout( callback, 1000 / 60 );
				        };

			})();

 
			var canvas, 
			    gl, 
			    buffer, 
			    vertex_shader, fragment_shader, 
			    currentProgram,
			    vertex_position,
			    timeLocation,
			    resolutionLocation,
			    parameters = {  start_time  : new Date().getTime(), 
			                    time        : 0, 
			                    screenWidth : 0, 
			                    screenHeight: 0 };
 
			init();
			animate();
 
			function init() {
 
				vertex_shader = document.getElementById('vs').textContent;
				fragment_shader = document.getElementById('fs').textContent;
 

				canvas = document.getElementById("myCanvas");
				// canvas = document.querySelector( 'canvas' );
 
				// Initialise WebGL
 
				try {
 
					gl = canvas.getContext( 'webgl2' );
 
				} catch( error ) { }
 
				if ( !gl ) {
 
					throw "cannot create webgl context";
 
				}
 
				// Create Vertex buffer (2 triangles)
 
				buffer = gl.createBuffer();
				gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
				gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( [ - 1.0, - 1.0, 1.0, - 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0 ] ), gl.STATIC_DRAW );
 
				// Create Program
 
				currentProgram = createProgram( vertex_shader, fragment_shader );

				timeLocation = gl.getUniformLocation( currentProgram, 'time' );
				resolutionLocation = gl.getUniformLocation( currentProgram, 'resolution' );
 
			}
 
			function createProgram( vertex, fragment ) {
 
				var program = gl.createProgram();
 
				var vs = createShader( vertex, gl.VERTEX_SHADER );
				var fs = createShader( '#ifdef GL_ES\nprecision highp float;\n#endif\n\n' + fragment, gl.FRAGMENT_SHADER );
 
				if ( vs == null || fs == null ) return null;
 
				gl.attachShader( program, vs );
				gl.attachShader( program, fs );
 
				gl.deleteShader( vs );
				gl.deleteShader( fs );
 
				gl.linkProgram( program );
 
				if ( !gl.getProgramParameter( program, gl.LINK_STATUS ) ) {
 
					alert( "ERROR:\n" +
					"VALIDATE_STATUS: " + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) + "\n" +
					"ERROR: " + gl.getError() + "\n\n" +
					"- Vertex Shader -\n" + vertex + "\n\n" +
					"- Fragment Shader -\n" + fragment );
 
					return null;
 
				}
 
				return program;
 
			}
 
			function createShader( src, type ) {
 
				var shader = gl.createShader( type );
 
				gl.shaderSource( shader, src );
				gl.compileShader( shader );
 
				if ( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {
 
					alert( ( type == gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT" ) + " SHADER:\n" + gl.getShaderInfoLog( shader ) );
					return null;
 
				}
 
				return shader;
 
			}
 
			function resizeCanvas( event ) {
 
				// if ( canvas.width != canvas.clientWidth ||
				// 	 canvas.height != canvas.clientHeight ) {

				// 	canvas.width = canvas.clientWidth;
				// 	canvas.height = canvas.clientHeight;

				// 	parameters.screenWidth = canvas.width;
				// 	parameters.screenHeight = canvas.height;

				// 	gl.viewport( 0, 0, canvas.width, canvas.height );

				// }
				
			}
 
			function animate() {
				resizeCanvas();
				render();
				requestAnimationFrame( animate );
 
			}
 
			function render() {
 
				if ( !currentProgram ) return;
 
				parameters.time = new Date().getTime() - parameters.start_time;
 
				gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
 
				// Load program into GPU
 
				gl.useProgram( currentProgram );
 
				// Set values to program variables
 
				gl.uniform1f( timeLocation, parameters.time / 1000 );
				gl.uniform2f( resolutionLocation, canvas.width, canvas.height );
				// Render geometry
 
				gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
				gl.vertexAttribPointer( vertex_position, 2, gl.FLOAT, false, 0, 0 );
				gl.enableVertexAttribArray( vertex_position );
				gl.drawArrays( gl.TRIANGLES, 0, 6 );
				gl.disableVertexAttribArray( vertex_position );
				// console.log(parameters.screenWidth)
			}
 
		</script> 
 
	</body> 
</html>