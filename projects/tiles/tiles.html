<!DOCTYPE HTML> 
<html> 
	<head> 
		<meta charset="utf-8"> 
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<title>tiles generative art</title> 
		
		<style> 
			html, body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
				width: 100%;
				height: 100%;
			}
			/* canvas {
				width: 100%;
				height: 100%;
			} */
		</style> 
	</head> 
	<body> 
        <p>&nbsp;</p> 
        <center>
            <canvas  id="myCanvas" width =600 height=900> </canvas>
        </center> 

		<!-- <canvas></canvas> -->
		<div id="info"></div> 
 
		<script id="vs" type="x-shader/vertex"> 
			attribute vec3 position;
 
			void main() {
 
				gl_Position = vec4( position, 1.0 );
 
			}
 
		</script> 
 
		<script id="fs" type="x-shader/fragment"> 
			precision highp float;

			uniform float u_time;
			uniform vec2 u_resolution; //vec2(screen_width,screen_height)
            uniform float u_numTilesX;
            uniform float u_numTilesY;
			uniform float u_tileSlits;
			uniform vec3 u_color1;
			uniform vec3 u_color2;

			//below random + noise from the book of shaders 
			//https://thebookofshaders.com/11/

			// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW
			float hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }
			float hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }
			
			float random (in vec2 st) {
				return fract(sin(dot(st.xy,
									 vec2(12.9898,78.233)))*
					43758.5453123);
			}
			
			// Based on Morgan McGuire @morgan3d
			// https://www.shadertoy.com/view/4dS3Wd
			float noise (in vec2 st) {
				vec2 i = floor(st);
				vec2 f = fract(st);
			
				// Four corners in 2D of a tile
				float a = random(i);
				float b = random(i + vec2(1.0, 0.0));
				float c = random(i + vec2(0.0, 1.0));
				float d = random(i + vec2(1.0, 1.0));
			
				vec2 u = f * f * (3.0 - 2.0 * f);
			
				return mix(a, b, u.x) +
						(c - a)* u.y * (1.0 - u.x) +
						(d - b) * u.x * u.y;
			}
			
			#define OCTAVES 6
			float fbm (in vec2 st) {
				// Initial values
				float value = 0.0;
				float amplitude = .5;
				float frequency = 0.;
				//
				// Loop of octaves
				for (int i = 0; i < OCTAVES; i++) {
					value += amplitude * noise(st);
					st *= 2.;
					amplitude *= .5;
				}
				return value;
			}

			//classic hsv to rgb conversion
			vec3 hsv2rgb(vec3 c) {
				vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
				vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
				return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
			}

			vec3 pastelColor(vec3 c) {
				return mix(c,vec3(210.0/360.0,0.01,1.0),0.5);
			}


			float remap(float x) {
				if (x > 0.3 && x < 0.7) {
					return step(0.5,x);
				}
				return x;
			}

            vec3 generateBlock(vec2 canvasUV, vec2 tileUV) {
				vec2 tileNums = floor(canvasUV*vec2(u_numTilesX,u_numTilesY))+vec2(1.0); //determine the tile num for the x and y directions (starting from 1)
				float tileIndex = (u_numTilesX*(tileNums.y-1.0))+tileNums.x; //create an index for each tile
				
				float flipVal = mix(1.0,0.0,mod(tileNums.y,2.0)); //if sequence should be staggered then use flip val of 1 to set the index to odd or even accordingly

				vec2 gridUV = fract(tileUV * u_tileSlits); //rows or cols within a tile
				
				float tileOrientation = mod(tileIndex+flipVal,2.0);
				vec2 noiseSample = mix(vec2(gridUV.x,tileUV.y),vec2(tileUV.x,gridUV.y),tileOrientation); //determine the tile orientation
				float i = noise(((noiseSample+tileIndex+u_time)*2.0)); //sample the noise function based the sample cords, tile index, and time to animate
				
				//i = remap(i);

				float mixer = random(vec2(tileNums));
				mixer = 0.5;

				vec3 light1 = mix(u_color1,vec3(1.0),mixer);
				vec3 light2 = mix(u_color2,vec3(1.0),mixer);
				vec3 dark1 = mix(u_color1,vec3(0.0),0.5);
				vec3 dark2 = mix(u_color2,vec3(0.0),0.5);
				vec3 pastel1 = hsv2rgb(pastelColor(u_color1));
				vec3 pastel2 = hsv2rgb(pastelColor(u_color2));

				return mix(light1,dark2,i);
                //return mix(mix(light1,dark2,i),mix(light2,dark1,i),tileOrientation);
            }

			void main( void ) {
				vec2 uv = gl_FragCoord.xy / u_resolution.xy; //calc quad uv (0-1) down to up and left to right
                
				//scale the uv by the x and y tile amounts
				//and create fractional uvs within each tile
				vec2 tileUV = fract(vec2(uv.x*u_numTilesX,uv.y*u_numTilesY)); 

				gl_FragColor = vec4(generateBlock(uv,tileUV),1.0);
			}
			
		</script> 
 
		<script> 
 
			/**
			 * Provides requestAnimationFrame in a cross browser way.
			 * paulirish.com/2011/requestanimationframe-for-smart-animating/
			 */
			window.requestAnimationFrame = window.requestAnimationFrame || ( function() {

				return  window.webkitRequestAnimationFrame ||
				        window.mozRequestAnimationFrame ||
				        window.oRequestAnimationFrame ||
				        window.msRequestAnimationFrame ||
				        function(  callback, element ) {
					        window.setTimeout( callback, 1000 / 60 );
				        };

			})();

 
			var canvas, 
			    gl, 
			    buffer, 
			    vertex_shader, fragment_shader, 
			    currentProgram,
			    vertex_position,
			    timeLocation,
			    resolutionLocation,
                numTilesX,
				genTilesX,
                numTilesY,
				genTilesY,
				tileSlits,
				genSlits,
				color1,
				genColor1,
				color2,
				genColor2,
			    parameters = {  start_time  : new Date().getTime(), 
			                    time        : 0, 
			                    screenWidth : 0, 
			                    screenHeight: 0 };
 
			init();
			animate();


			function randomInt(min, max) {
				return Math.floor(min + (Math.random()*(max-min)))
			}

			//return a random color
			function randomColor() {
				return [Math.random(),Math.random(),Math.random()]
			}

			function init() {
 
				vertex_shader = document.getElementById('vs').textContent;
				fragment_shader = document.getElementById('fs').textContent;
 

				canvas = document.getElementById("myCanvas");
				// canvas = document.querySelector( 'canvas' );
 
				// Initialise WebGL
 
				try {
 
					gl = canvas.getContext( 'webgl2' );
 
				} catch( error ) { }
 
				if ( !gl ) {
 
					throw "cannot create webgl context";
 
				}
 
				// Create Vertex buffer (2 triangles)
 
				buffer = gl.createBuffer();
				gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
				gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( [ - 1.0, - 1.0, 1.0, - 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0 ] ), gl.STATIC_DRAW );
 
				// Create Program
 
				currentProgram = createProgram( vertex_shader, fragment_shader );

				//set uniforms
				timeLocation = gl.getUniformLocation( currentProgram, 'u_time' );
				resolutionLocation = gl.getUniformLocation( currentProgram, 'u_resolution' );
                numTilesX = gl.getUniformLocation(currentProgram, 'u_numTilesX');
                numTilesY = gl.getUniformLocation(currentProgram, 'u_numTilesY'); 
				tileSlits = gl.getUniformLocation(currentProgram, 'u_tileSlits'); 
				color1 =  gl.getUniformLocation(currentProgram, 'u_color1'); 
				color2 = gl.getUniformLocation(currentProgram, 'u_color2'); 

				//generative elements
				genTilesX = randomInt(4,20);
				genTilesY = Math.floor(genTilesX*(3/2));
				genSlits = randomInt(5,10);
				genColor1 = randomColor()
				genColor2 = randomColor()
			}
 
			function createProgram( vertex, fragment ) {
 
				var program = gl.createProgram();
 
				var vs = createShader( vertex, gl.VERTEX_SHADER );
				var fs = createShader( '#ifdef GL_ES\nprecision highp float;\n#endif\n\n' + fragment, gl.FRAGMENT_SHADER );
 
				if ( vs == null || fs == null ) return null;
 
				gl.attachShader( program, vs );
				gl.attachShader( program, fs );
 
				gl.deleteShader( vs );
				gl.deleteShader( fs );
 
				gl.linkProgram( program );
 
				if ( !gl.getProgramParameter( program, gl.LINK_STATUS ) ) {
 
					alert( "ERROR:\n" +
					"VALIDATE_STATUS: " + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) + "\n" +
					"ERROR: " + gl.getError() + "\n\n" +
					"- Vertex Shader -\n" + vertex + "\n\n" +
					"- Fragment Shader -\n" + fragment );
 
					return null;
 
				}
 
				return program;
 
			}
 
			function createShader( src, type ) {
 
				var shader = gl.createShader( type );
 
				gl.shaderSource( shader, src );
				gl.compileShader( shader );
 
				if ( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {
 
					alert( ( type == gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT" ) + " SHADER:\n" + gl.getShaderInfoLog( shader ) );
					return null;
 
				}
 
				return shader;
 
			}
 
			function resizeCanvas( event ) {
 
				// if ( canvas.width != canvas.clientWidth ||
				// 	 canvas.height != canvas.clientHeight ) {

				// 	canvas.width = canvas.clientWidth;
				// 	canvas.height = canvas.clientHeight;

				// 	parameters.screenWidth = canvas.width;
				// 	parameters.screenHeight = canvas.height;

				// 	gl.viewport( 0, 0, canvas.width, canvas.height );

				// }
				
			}

			
			function animate() {
				resizeCanvas();
				render();
				requestAnimationFrame( animate );
 
			}
 
			function render() {
 
				if ( !currentProgram ) return;
 
				parameters.time = new Date().getTime() - parameters.start_time;
 
				gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
 
				// Load program into GPU
 
				gl.useProgram( currentProgram );
 
				// Set values to program variables
 
				gl.uniform1f( timeLocation, parameters.time / 1000 );
				gl.uniform2f( resolutionLocation, canvas.width, canvas.height );
                gl.uniform1f( numTilesX, genTilesX);
                gl.uniform1f( numTilesY, genTilesY);
				gl.uniform1f( tileSlits, genSlits);
				gl.uniform3fv(color1,  genColor1);
				gl.uniform3fv(color2,  genColor2);

				// Render geometry
 
				gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
				gl.vertexAttribPointer( vertex_position, 2, gl.FLOAT, false, 0, 0 );
				gl.enableVertexAttribArray( vertex_position );
				gl.drawArrays( gl.TRIANGLES, 0, 6 );
				gl.disableVertexAttribArray( vertex_position );
				// console.log(parameters.screenWidth)
			}
 
		</script> 
 
	</body> 
</html>